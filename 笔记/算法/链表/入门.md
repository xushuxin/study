##### 概念

​	链表存储有序的元素集合，每个元素由一个存储元素本身的节点和一个指向下一个元素的引用(也称指针或链接)组成。

##### 数组与链表的区别

+ 数组中的元素是连续放置的；而链表不是
+ 从数组起点或者中间插入或者移除元素，成本很高，因为需要移动元素；链表添加和移除元素时不需要移动其他元素
+ 可以直接访问数组任何位置的元素；而要访问链表中间的一个元素，需要从表头开始迭代查找，直到找到所需元素

##### 链表的创建

我们使用动态原型模式来创建一个链表。列表最后一个节点的下一个元素始终是null。

```js
function LinkedList(){
  function Node(element){
    this.element = element;
    this.next = null;
  }
  this.head = null;
  this.length = 0;
  //通过对一个方法append判断就可以知道是否设置了prototype
  if((typeof this.append !== 'function')&&(typeof this.append !== 'string')){
    //添加元素
    LinkedList.prototype.append = function(element){
      var node = new Node(element);
      var current;
      if(this.head === null){
        this.head = node;
      }else{
        current = this.head;
        while(current.next !== null){
          current = current.next;
        }
        current.next = node;
      }
      this.length++;
    };
    //插入元素，成功true，失败false
    LinkedList.prototype.insert = function(position,element){
      if(position > -1 && position < this.length){
        var current = this.head;
        var previous;
        var index = 0;
        var node = new Node(element);
        if(position == 0){
          node.next = current;
          this.head = node;
        }else{
          while(index++ < position){
            previous = current;
            current = current.next;
          }
          node.next = current;
          previous.next = node;
        }
        this.length++;
        return true;
      }else{
        return false;
      }
    };
    //根据位置删除指定元素，成功 返回元素， 失败 返回null
    LinkedList.prototype.removeAt = function(position){
      if(position > -1 && position < this.length){
        var current = this.head;
        var previous = null;
        var index = 0;
        if(position == 0){
          this.head = current.next;
        }else{
          while(index++ < position){
            previous = current;
            current = current.next;
          }
          previous.next = current.next;
        }
        this.length--;
        return current.element;
      }else{
        return null;
      }
    };
    //根据元素删除指定元素，成功 返回元素， 失败 返回null
    LinkedList.prototype.remove = function(element){
      var index = this.indexOf(element);
      return this.removeAt(index);
    };
    //返回给定元素的索引，如果没有则返回-1
    LinkedList.prototype.indexOf = function(element){
      var current = this.head;
      var index = 0;
      while(current){
        if(current.element === element){
          return index;
        }
        index++;
        current = current.next;
      }
      return -1;
    };
    LinkedList.prototype.isEmpty = function(){
      return this.length === 0;
    };
    LinkedList.prototype.size = function(){
      return this.length;
    };
    LinkedList.prototype.toString = function(){
      var string = '';
      var current = this.head;
      while(current){
        string += current.element;
        current = current.next;
      }
      return string;
    };
    LinkedList.prototype.getHead = function(){
      return this.head;
    };
  }
}
```

##### 链表的基本使用

```js
 var linkedList = new LinkedList();
console.log(linkedList.isEmpty());//true;
linkedList.append('huang');
linkedList.append('du')
linkedList.insert(1,'cheng');
console.log(linkedList.toString());//huangchengdu
console.log(linkedList.indexOf('du'));//2
console.log(linkedList.size());//3
console.log(linkedList.removeAt(2));//du
console.log(linkedList.toString());//huangcheng
```

##### 双向链表

链表有多种不同的类型,这一节介绍双向链表。双向链表和普通链表的区别在于,在链表中, 一个节点只有链向下一个节点的链接,而在双向链表中,链接是双向的:一个链向下一个元素, 另一个链向前一个元素。

双向链表和链表的区别就是有一个tail属性，所以必须重写insert、append、removeAt方法。每个节点对应的Node也多了一个prev属性。

```js
//寄生组合式继承实现，详见javascript高级程序设计第七章
function inheritPrototype(subType, superType) {
  function object(o) {
    function F() {}
    F.prototype = o;
    return new F();
  }
  var prototype = object(superType.prototype);
  prototype.constructor = subType;
  subType.prototype = prototype;
}
function DoublyLinkedList() {
  function Node(element) {
    this.element = element;
    this.next = null;
    this.prev = null;
  }
  this.tail = null;
  LinkedList.call(this);
  //与LinkedList不同的方法自己实现。
  this.insert = function(position, element) {
    if (position > -1 && position <= this.length) {
      var node = new Node(element);
      var current = this.head;
      var previous;
      var index = 0;
      if (position === 0) {
        if (!this.head) {
          this.head = node;
          this.tail = node;
        } else {
          node.next = current;
          current.prev = node;
          this.head = node;
        }
      } else if (position == this.length) {
        current = this.tail;
        current.next = node;
        node.prev = current;
        this.tail = node;
      } else {
        while (index++ < position) {
          previous = current;
          current = current.next;
        }
        previous.next = node;
        node.next = current;
        current.prev = node;
        node.prev = previous;
      }
      this.length++;
      return true;
    } else {
      return false;
    }
  };
  this.append = function(element) {
    var node = new Node(element);
    var current;
    if (this.head === null) {
      this.head = node;
      this.tail = node;
    } else {
      current = this.head;
      while (current.next !== null) {
        current = current.next;
      }
      current.next = node;
      node.prev = current;
      this.tail = node;
    }
    this.length++;
  };
  this.removeAt = function(position) {
    if (position > -1 && position < this.length) {
      var current = this.head;
      var previous;
      var index = 0;
      if (position === 0) {
        this.head = current.next;
        if (this.length === 1) {
          this.tail = null;
        } else {
          this.head.prev = null;
        }
      } else if (position === (this.length - 1)) {
        current = this.tail;
        this.tail = current.prev;
        this.tail.next = null;
      } else {
        while (index++ < position) {
          previous = current;
          current = current.next;
        }
        previous.next = current.next;
        current.next.prev = previous;
      }
      this.length--;
      return current.element;
    } else {
      return false;
    }
  };
}
inheritPrototype(DoublyLinkedList, LinkedList);
```

##### 双向链表的基本使用

```js
var doublyList = new DoublyLinkedList();
console.log(doublyList.isEmpty()); //true;
doublyList.append('huang');
doublyList.append('du')
doublyList.insert(1, 'cheng');
console.log(doublyList.toString()); //huangchengdu
console.log(doublyList.indexOf('du')); //2
console.log(doublyList.size()); //3
console.log(doublyList.removeAt(2)); //du
console.log(doublyList.toString()); //huangcheng
```

##### 循环链表

​	循环链表可以像链表一样只有单向引用,也可以像双向链表一样有双向引用。循环链表和链 表之间唯一的区别在于,最后一个元素指向下一个元素的指针(tail.next)不是引用null, 而是指向第一个元素(head)。双向循环链表有指向head元素的tail.next,和指向tail元素的head.prev。
