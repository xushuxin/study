啊哈算法-第四章 第2节

```JS
function getMinimum(n, m, map, startX, startY, endX, endY) {
  let min = 9999,
    book = Array(51).fill(undefined).map(item=>Array(51).fill(0));

  function dfs(x, y, step) {
    let next = [
      [0, 1], //向右走（y轴坐标加1）
      [1, 0], //向下走（x轴坐标加1）
      [0, -1], //向右走（y轴坐标减1）
      [-1, 0] //向上走（x轴坐标减1）
    ];
    let tx, ty, k;
    //递归结束条件
    if (x === endX && y === endY) { //已到达目的地
      if (step < min) { //如果此方案比之前的方案需要的步数少
        min = step; //获取最小步数
      }
      return; //停止递归
    }
    //枚举4种走法
    for (k = 0; k <= 3; k++) {
      tx = x + next[k][0];
      ty = y + next[k][1];
      //判断坐标是否超过给定的图的范围,直接跳过这种走法
      if (tx < 1 || tx > n || ty < 1 || ty > m) continue;
      //不是路障，并且不是已走过的路径
      //map索引从0开始，所以要减去1
      if (map[tx-1][ty-1] == 0 && book[tx][ty] == 0) {
        book[tx][ty] = 1; //标记为已走过
        dfs(tx, ty, step + 1); //递归处理下个坐标
        book[tx][ty] = 0;//往回退，查找是否有其它的路径
      }
    }
  }
  dfs(startX, startY, 0) //从起始坐标开始，步数为0
  // console.log(book)
  return min;
}
console.log(getMinimum(
  5, 4, //行列
  [ //地图
    [0, 0, 1, 0],
    [0, 0, 0, 0],
    [0, 0, 1, 0],
    [0, 1, 0, 0],
    [0, 0, 0, 1],
  ],
  1, 1, //起始点坐标
  4, 3 //目标点坐标
))
```

