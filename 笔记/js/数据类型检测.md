# 数据类型检测
### typeof ：可以区分除对象和数组，null之外的其他值的类型，一般用来检测除null之外的基本数据类型
```js
+ 返回结果是一个字符串，字符串中包含了对应的数据类型 "number/string/boolean/undefined/symbol/bigint/object/function"   
+ typeof typeof xxx  结果都是：“string”    
```
- - - -
### instanceof （不推荐使用）
 + 并不是检测数据类型的，是用来检测当前实例是否属于这个类，只是被“打肿脸充胖子了”
 + 用它来检测，一般只应用于普通对象/数组对象/正则对象/日期对象等的具体细分的
 + “打肿脸充胖子”的东西就是不好用，存在很多问题

基于 “实例 instanceof 类” 检测的时候，浏览器底层是这样处理的
使用Function.prototype上的Symbol.hasInstance方法
	1. Function.prototype[Symbol.hasInstance]=function [Symbol.hasInstance](){[native code]}
	2. Symbol.hasInstance方法执行的原理
  + 根据当前实例的原型链上(\_\_proto__)是否存在这个类的原型(prototype)
  + arr.\__proto__===Array.prototype   => arr instanceof Array  : true
  + arr.\__proto__.__proto__===Object.prototype => arr instanceof Object : true

普通对象不可以使用instanceof的原因：
```js
let obj = {};
console.log(arr instanceof obj); //Uncaught TypeError: Right-hand side of 'instanceof' is not callable ，报错原因是因为 obj 是一个对象，它没有[Symbol.hasInstance]这个属性（函数才可以调用Function.prototype上的这个方法）
```
1. 所有的引用类型的实例都是Object的实例

   实例 instanceof Object 结果为true，不能证明实例就是普通对象

```js
console.log([] instanceof Object);//true
console.log(function(){} instanceof Object);//true
console.log(/\d/ instanceof Object);//true
```
2. instanceof不可以用于基本数据类型值

```js
let n = 10;
let m = new Number(10);
console.log(n.toFixed(2)); //"10.00"  n是Number类的实例，只不过它是字面量方式创造出来的原始类型值而已（其实n.toFixed(2)的时候，n这个基本类型值浏览期内部也会把它 Object(n)一下，然后在调用方法，因为此时它就具备__proto__）
console.log(m.toFixed(2)); //"10.00"  m也是Number类的实例，只不过它是构造函数方式创造出来的引用类型值而已
console.log(n instanceof Number); //false
console.log(m instanceof Number); //true
```
3. 原型重写导致的问题

①如果不小心重写了实例的原型链（__proto__），会导致检测不准确，下面这个例子检测一个对象是否为Array的实例，结果会返回true
```js
var obj = {};
obj.__proto__=Array.prototype;
let isArray = obj instanceof Array;
console.log(isArray);//true
```
②还有如果修改了构造函数的prototype指向,检测数据类型也是不准确的
```js
function C(){};
C.prototype = Array.prototype;
var obj =new C();
console.log(obj);//虽然obj可以基于__proto__找到Array.prototype，但是它不具备数组的任何特征(length/索引都没有的)，所以断定这货一定不是一个数组
console.log(obj instanceof  Array);//true
```
③在浏览器中，我们的脚本可能需要在多个窗口之间进行交互。多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。这可能会引发一些问题。比如，表达式 [] instanceof window.frames[0].Array 会返回 false，因为 Array.prototype !== window.frames[0].Array.prototype，并且数组从前者继承。

**重写instanceof**
```js
// + obj要检测的实例对象（不支持原始值类型）
// + constructor要检测的类（必须是一个函数）
function instance_of(obj, constructor) {
    // 参数校验
    if (obj == null || !/^(object|function)$/i.test(typeof obj)) return false;
    if (typeof constructor !== "function") throw new TypeError("Right-hand side of 'instanceof' is not callable");

    // obj.__proto__ === Object.getPrototypeOf(obj)
    let proto = Object.getPrototypeOf(obj),
        prototype = constructor.prototype;
    while (true) {
        // 找到Object.prototype.__proto__都没有相等的，则证明不是当前类的实例
        if (proto === null) return false;
        // 找到对象的原型链包含类的原型，则证明对象是类的一个实例
        if (proto === prototype) return true;
        // 一级级查找即可
        proto = Object.getPrototypeOf(proto);
    }
}
console.log(instance_of([], Array)); //true
console.log(instance_of([], Object)); //true
console.log(instance_of([], RegExp)); //false
console.log(instance_of(10, Number)); //false
console.log(instance_of(new Number(10), Number)); //true
console.log(instance_of([], {})); //报错
```
或者递归方式实现
```js
function instance_of(value, Ctor) {
  //如果不是引用类型返回false
  if (!/^(object|function)$/.test(typeof value) || value === null) return false;
  if (typeof Ctor !== "function") throw new TypeError("Right-hand side of 'instanceof' is not callable");

  let proto = Object.getPrototypeOf(value);
  if (proto === Ctor.prototype) {
    return true;
  } else if (proto !== null) {
    return instance_of(proto, Ctor)
  }
  return false;
}
var arr = [];
console.log(instance_of([], Array)); //true
console.log(instance_of([], Object)); //true
console.log(instance_of([], RegExp)); //false
console.log(instance_of(10, Number)); //false
console.log(instance_of(new Number(10), Number)); //true
console.log(instance_of([], {})); //报错
```
- - - -
### obj.constructor === 构造函数 
 + 一样是打肿脸充胖子，原本就是获取实例的构造函数的，基于这些特点可以充当数据类型检测
 + 而且这货比instancof还好用一些
 + 但是也不准确：constructor是可以随意被修改的

在constructor不被修改的情况下，这样区分是数组还是普通对象
```js
let arr = [];
console.log(arr.constructor === Array); //true 
console.log(arr.constructor === Object); //false
console.log(arr.constructor === RegExp); //false 
```
一但原型重定向，constructor也改了，所以也就不准了
```js
function Person() {}
Person.prototype = Array.prototype;
let p1 = new Person;
console.log(p1.constructor === Array); //true 
```
检测
```js
let n = 10;
let m = new Number(10);
console.log(n.constructor === Number); //true
console.log(m.constructor === Number); //true 
```
- - - -
### Object.prototype.toString.call(obj)  检测所有类型
调用对象原型上的toString方法检测，目前是最准确的方法
   + 专门用来检测数据类型的(很强大很暴力的一种办法，基本零瑕疵)
   + Number/String/Boolean/Symbol/BigInt/Function/Array/RegExp/Date/Object...的原型上都有toString，除了Object.prototype.toString不是转换字符串的，其余都是，Object.prototype.toString是用来检测数据类型的
   + 返回结果 "[object 对象[Symbol.toStringTag]||对象.构造函数(不受自己更改的影响,对内置类有效)||Object]"
```js
let class2type = {},
toString = class2type.toString;//Object.prototype.toString
```

```js
class Person {
    //只要获取实例的[Symbol.toStringTag]属性值，则调用这个方法
    get[Symbol.toStringTag]() {
        return "Person";
    }
}
let p1 = new Person; 
toString.call(p1) //=> "[object Person]"
```

- - - -
扩展：
```js
console.log(typeof {});//"object"
console.log(typeof null);//"object"
console.log(typeof []);//"object"
```

1. typeof检测对象和null都为"object"的原因：
    js的c++源码中，用3位的type标签来区分数据类型，在定义null时使用的是object的type标签加上0的引用;判断类型的时候，仅根据type标签去判断是否为对象，所以会把null也检测为"object";
    [jsapi.h - DXR](https://dxr.mozilla.org/classic/source/js/src/jsapi.h)32行：
    ![C417EE55-7145-4041-9CF5-6BA654716F17-6045621](/Users/xushuxin/Library/Application Support/typora-user-images/C417EE55-7145-4041-9CF5-6BA654716F17-6045621.png)
    [jsapi.h - DXR](https://dxr.mozilla.org/classic/source/js/src/jsapi.h)110行：派生值定义
    undefined、null、0、1、false、true

  ![4D703834-2AD4-4B71-826B-2886E1002252-6045665](/Users/xushuxin/Library/Application Support/typora-user-images/4D703834-2AD4-4B71-826B-2886E1002252-6045665.png)

  [jsapi.h - DXR](https://dxr.mozilla.org/classic/source/js/src/jsapi.h)47行：类型判断
  ![DAA04DF9-9E92-474E-A8C9-EC829E1E3678](/Users/xushuxin/Library/Application Support/typora-user-images/DAA04DF9-9E92-474E-A8C9-EC829E1E3678.png)

  [jsapi.c - DXR](https://dxr.mozilla.org/classic/source/js/src/jsapi.c#332) 332行：

  ![EBD7C1AE-FC1F-4C3C-B940-37401C9132E7](/Users/xushuxin/Library/Application Support/typora-user-images/EBD7C1AE-FC1F-4C3C-B940-37401C9132E7.png)

2. typeof检测对象和数组都为”object“的原因：
    js源码中并没有定义数组类型的type标签，并且在判断对象类型时，仅将函数类型单独区分了（这也是typeof 函数 为"function"的原因）。
    [The history of “typeof null”](https://2ality.com/2013/10/typeof-null.html)此文章所描述的type标签于源码中的不一致，需要验证是否后续有所改动源码？
    源码地址：[jsapi.h - DXR](https://dxr.mozilla.org/classic/source/js/src/jsapi.h)

