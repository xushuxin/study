#### webpack的作用

1. 代码转换
2. 文件优化
3. 代码分割
4. 模块合并
5. 自动刷新
6. 自动发布

#### 首先必须安装node 

node -v 检测node版本

#### 项目初始化

npm init -y 

#### webpack安装

**下载nrm可以用于切换下载npm包的源**

npm i nrm -g  

执行命令 nrm ls查看当前源

**下载webpack 和 webpack-cli （开发环境依赖）**

npm install  webapck webpack-cli -D

**0配置运行：**

npx  webpack      npx是5.2版本以后npm提供的命令

运行原理：执行node_modules下.bin下可执行文件webapck命令，命令内部会调用webpack-cli解析用户参数进行打包

默认配置：

打包入口文件路径: ./src/index.js

打包输出目录./dist

输出js文件名main.js

默认配置文件：webpack.config.js 或 webpackfile.js

### 自定义配置：

1. #### package.json的script配置命令

   webpack命令行flags

   --mode 设置模式（生产/开发）

   --config 设置webpack 配置文件的路径

   --env  如果指定的配置文件导出的是一个函数，会把参数传给这个函数第一个形参(webapck4和webpack5有区别)

   以下是webpack4的用法

   ```json
   "script":{
   
   	"dev":"webpack --mode development --config ./webpack.dev.js"
   
   }
   ```

   npm run dev 开发环境运行

   npm run build 生产环境运行

2. #### webpack具体配置

   webpack配置遵循commonJS语法规范，可以使用node的内置模块

   以开发环境为例：

   webpack.dev.js配置：

   ```JS
   module.exports = {
     mode:"development",//指定webpack所需的mode，可选：development/production
     entry:"./src/index.js",//可以指定一个（或多个）不同的入口起点
     output:{
       path:path.resolve(__dirname,'output'),//打包输出目录
       filename:'index.js'//打包输出的结果文件
     }
   }
   ```

3. #### 公共配置与不同环境配置的合并(两种)

  1) 使用同一个配置文件

+ 不同环境的命令行中通过命令--env的配置不同参数用于区分环境（可以自定义），并且配置文件指向同一个文件，配置文件需要导出一个函数，第一个参数用于接收env的值;
+ 不同环境需要使用同一个配置文件

  2) 把公共配置引入到不同配置文件合并

webpack4实现配置合并需要自己下载引入webpack-merge模块，然后在一个配置文件中（如webpack.config.js）根据env的不同，合并公共配置和对应模式的配置并返回作为最终配置。

webpack5提供命令行模式（--merge, -m）：使用 webpack-merge 合并两个配置文件

例如 `--merge -c ./webpack.config.js -c ./webpack.dev.config.js`

4. #### 插件的使用(提供额外的功能)

   https://www.npmjs.com/ 搜索对应插件名，查看使用方法和配置

   + **清除输出目录   clean-webapck-plugin**  
   + **把打包后的js文件自动引入到html中   html-webpack-plugin**    
       1. 把指定位置的html文件打包生成到webapck配置的输出目录（可以指定输出的文件名）
       2. 可以自动把webpack打包后的js文件引入html（inject指定位置如'head'、'body'等）
       3. 引入的js可以设置hash
       4. 可以进行一些html文件压缩配置
       5. 设置网站标题，在html模板上使用Ejs语法获取
       6. favicon设置（也可以通过在模板上写固定路径，copy-webpack-plugin实现静态资源复制）
   + **把css单独打包成一个css文件  mini-css-extract-plugin，配合loader使用，通过link标签方式加载css**
   + **复制静态资源到打包输出目录：copy-webpack-plugin**
   + **把指定文件地址（可以是CDN地址或者相对依赖包的目录），通过script/link 标签插入到页面：html-webpack-externals-plugin**
5. #### 启动本地服务  webpack-dev-server
   + 是在**内存中**打包，并且自动启动服务(因为是在内存中打包，所以看不到打包后的文件）

   + **访问本地服务器的地址时，会默认查找是否有html文件，有会默认打开**

   首先，默认访问本地服务器文件时会在**内存中**webpack打包输出目录查找指定文件；如果没有该文件，会基于contentBase路径查找文件，contentBase默认是当前项目文件夹，可以通过devServer.contentBase自定义

   + 开启**热更新**后，内部使用的js、css修改会页面自动更新，模板文件内容发生改变需要手动刷新页面才能看到更新

   + **proxy** 使用本地node服务，代理发送请求
   
     + 必须以匹配的字符串开头的请求路径才会代理（只写"api"是不会代理的），或者也可以使用*或者/匹配所有的请求路径
     + 路径重写
   
     ```js
     proxy:{//设置代理（通过node本地服务发送和接收请求数据）：
       // 写法1：可以用 * 或者 / 匹配任意请求路径
       "/api":"http://baidu.com",//只要请求以“/api”开头的,会发送到http://baidu.com
       //写法2：
       "/secondApi":{
         target:"http://baidu.com",
         //路径重写： 
         pathRewrite:{
         '^/secondApi':''//发代理请求时，把请求路径开头的"/api"去除
       	},
     	}
     }
     ==================
   //多个请求路径对应同一个代理地址的写法
     proxy:[{
         context:["/api","/secondApi"],
         target:"http://baidu.com",
         pathRewrite:{
           '^/secondApi':''//发代理请求时，把请求路径开头的"/api"去除
         },
     }]
     ```
     
   + **devServer.before**:请求服务之前，指定自定义的中间件，可以配置自定义处理程序（如mock数据）
     
     ```js
     //mockApi.js
     const mockApi = function(app,server){
       //修改数据需要重启项目
       app.get('/api/haha',function(req,res){
         res.json({custom:'response666'})
       })
     }
     module.exports = {
       mockApi
     }
     //====webpack.config.js====
     const {mockApi} = require('mockApi');
     devServer:{
       before:mockApi
     }
     ```
     
   +   了解：配合依赖**webpack-cli/serve 4.x.x版本**可以在命令行配置webpack serve 启动本地服务
   
     
   
6. #### 多入口打包

   - entry配置多入口js

   - output中filename使用[name].js匹配对应的入口文件名

   - 循环生成多个HtmlWebpackPlugin实例，对每个页面单独配置


7. #### loader使用

   loader加载顺序是**从右向左**, **从下往上**

   + **css-loader :把css转化成js识别的语法(主要是为了处理@import，url等引入的外部资源文件)**

   + **style-loader：js执行时把css通过style标签动态添加到页面（会导致js文件过大，实际项目不推荐使用）**

   + **可以使用插件mini-css-extract-plugin，使用其提供的loader，实现生成单独的css文件，并在生成的html文件用link标签方式引入**

   + **less-loader/sass-loader/scss-loader/stylus-loader：处理less/sass/scss/stylus文件，转化为css语法** 

     npm i less less-loader -D

     ```js
     rules:[
       {test:/\.less$/,use:[MiniCssExtractPlugin.loader,'css-loader','less-loader']}
     ]        
     ```
     
   + **postcss-loader：添加浏览器前缀**

     步骤：

     1.npm i postcss postcss-loader postcss-preset-env -D

     2.在style-loader,css-loader之前添加postcss-loader,但是要在预处理loader之后

     3.添加postcss配置，一般都单独写在postcss.config.js

     4.指定兼容浏览器版本，配置文件.browserslistrc

     postcss-preset-env的作用：让我们可以使用css新特性，并且包含autoprefixer

     postcss相关配置(需要下载相关插件)：

     [postcss中文文档](https://github.com/postcss/postcss/blob/HEAD/docs/README-cn.md)

     ```js
     plugins:[
     	"postcss-aspect-ratio-mini": {}, // 主要用来处理元素容器宽高比
       "postcss-write-svg": { utf8: false }, // 用来画1像素线
       'postcss-px-to-viewport': {
           viewportWidth: 750, // 视窗的宽度，对应的是我们设计稿的宽度，一般是750 
           viewportHeight: 1334, // 视窗的高度，根据750设备的宽度来指定，一般指定1334，也可以不配置 
           unitPrecision: 3, // 指定`px`转换为视窗单位值的小数位数（很多时候无法整除） 
           viewportUnit: 'vw', // 指定需要转换成的视窗单位，建议使用vw 
           selectorBlackList: ['.ignore', '.hairlines'], // 指定不转换为视窗单位的类，可以自定义，可以无限添加,建议定义一至两个通用的类名 
           minPixelValue: 1, // 小于或等于`1px`不转换为视窗单位，你也可以设置为你想要的值 
           mediaQuery: false // 允许在媒体查询中转换`px`
       },
       "postcss-pxtorem": { //官方网站https://www.npmjs.com/package/postcss-pxtorem
           rootValue: "100", //css文件中100px转为1rem，如750px会转为7.5rem
           propList: ["*", "!letter-spacing"], //转换的属性的列表，*表示通用,!加属性名表示不匹配指定属性
           selectorBlackList: [ //忽略的css选择器.ig-表示包含.ig-的都不转换,支持正则
             ".ig-"
           ],
           unitPrecision: 5, //保留rem小数点位数
           mediaQuery: false, //媒体查询中是否生效
           minPixelValue: 1 //px小于1不会转换
        }
     ]
     ```

     

   + **url-loader \ file-loader：处理图片、音视频、字体图标等资源**

     url-loader 的limit限制的字节数内，会使用url-loader转为base64的url，超出限制的文件会默认调用file-loader来生成图片文件，所以最好两个都下载

     ```js
     {
        test: /\.(png|jp(e)?g|gif|ico|svg|eot|ttf|woff|woff2)$/i,
         use: [{
           loader: "url-loader",
           options: {
             esModule: false, //不需要按照模块导出
             limit: 10 * 1024, //单位是Bit,小于10kb转为base64,大于10kb用file-loader生成图片资源
             name: "image/[name].[hash:5].[ext]", //file-load的配置，当图片大于limit指定大小时生效，生成图片的路径及名称（相对于webpack输出目录）
           },
         }, ],
     },
     ```

     limit：单位是Bit,小于10kb转为base64,大于10kb用file-loader生成图片资源

     name：file-load的配置，当图片大于url-load指定大小时生效，指定生成图片的路径及名称（相对于webpack输出目录）

   + html-withimg-loader  加载html页面引入的图片

     ```js
      { //加载html页面引入的图片
        test: /\.(html|htm)$/,
        use: 'html-withimg-loader'
      }
     ```

     

9. #### sourcemap的配置

   什么是source map：source map就是一个信息文件，储存着转换前后的位置信息。

   [JavaScript Source Map 详解](http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html)

   [sourcemap的配置分析](https://blog.csdn.net/liwusen/article/details/79414508)

   [sourcemap配置参数解析](https://www.cnblogs.com/axl234/p/6500534.html)

   ```js
   eval： 生成代码 每个模块都被eval执行，并且存在@sourceURL
   
   cheap-eval-source-map： 转换代码（行内） 每个模块被eval执行，并且sourcemap作为eval的一个dataurl
   
   cheap-module-eval-source-map： 原始代码（只有行内） 同样道理，但是更高的质量和更低的性能
   
   eval-source-map： 原始代码 同样道理，但是最高的质量和最低的性能
   
   cheap-source-map： 转换代码（行内） 生成的sourcemap没有列映射，从loaders生成的sourcemap没有被使用
   
   cheap-module-source-map： 原始代码（只有行内） 与上面一样除了每行特点的从loader中进行映射
   
   source-map： 原始代码 最好的sourcemap质量有完整的结果，但是会很慢
   ```

   + 首先要开启sourceMap,所有的loader，plugin都要设置允许sourceMap

   + 配置webpack的devtool选项：

     在开发环境中我们优先使用：cheap-module-eval-source-map

     在生产环境中我们使用：none（省略 `devtool` 选项）或者 source-map （@vue/cli设置productionSourceMap:false可以关闭生产环境的sourceMap）

10. #### webpack处理js


  需要借助Babel（把ES6+语法转为es5语法）[官网地址](https://www.babeljs.cn/)(插件下载)

   npm i babel-loader @babel/core @babel/preset-env -D

   babel-loader 用于处理js文件 
   @babel/core 转译的核心语法(不需要我们配置，babel-loader自动调用)

   @babel/preset-env  根据指定的目标环境，编译插件集合，并传递给babel-loader（新语法转为旧语法ES2~ES5）

​	@babel/preset-env不设置.browserslistrc的效果相当于把所有ES2015+语法转为ES5兼容

注意：

+ @babel/preset-env仅编译语句相关语法的插件，新的类及静态方法或者实例方法不会处理(比如Promise)

+ 如果要支持不支持es5语法的浏览器，比如ie8，需要使用es5-shim，转化es5语法

**某些语法(一般是处于提案阶段的语法)@babel/preset-env不提供预设，则需要自己安装插件处理**

**1. 如class的私有属性、静态属性的新写法**

```js
class Fn(){
  a = 1 //私有属性的新写法    
  static b = 2 //或者静态方法的新写法
}
    
```

下载依赖 npm i @babel/plugin-proposal-class-properties

```js
{
  test:/\.js$/,
    use:{
      loader:'babel-loader',
      options:{
          // exclude:/node_modules/,//排除指定文件或文件夹的编译
          presets:['@babel/preset-env'],
          plugins:[

             [ 
                "@babel/plugin-proposal-class-properties",//支持class相关的新的语法的插件
                {"loose":true}//宽松语法模式
             ]
          ]
       }
    }
}
```

**2. 打补丁，处理async、await语法，Promise（全局变量）、Array.from（静态方法）、[].includes (实例方法)等语法**

corejs2仅支持转化全局变量及静态方法

corejs3支持实例方法

plugin-transform-runtime 配合runtime-corejs3可以转化所有非提案阶段的实例及实例方法

1. 下载相关依赖

   npm i @babel/plugin-transform-runtime -D

   npm i @babel/runtime-corejs3 -S

   这里我们配置了corejs:3,所以下载@babel/runtime-corejs3

   **（todo: 为什么要作为生产依赖还没有弄清楚，因为我当做开发依赖安装，打包也没有问题,官方说的是运行时的依赖，所以我们就按官方说的来吧）**

   ![image-20201207233443404](/Users/xushuxin/Library/Application Support/typora-user-images/image-20201207233443404.png)

2. 使用

方法1：
```js
module:{
	rules:[
		{
      test: /\.js$/,
      use: {
        loader: 'babel-loader',
        options: {
          exclude: /node_modules/, 
          presets: ['@babel/preset-env'],
          plugins: [
            ['@babel/plugin-transform-runtime', {
              corejs: 3
            }]
          ]
        }
      }
    }
	]
}
```

注意：node_modules下的依赖不需要我们处理语法，所以使用exclude排除掉

方法2：

loader配置：

```
module:{
	rules:[
		{
      test: /\.js$/,
      use: 'babel-loader'
    }
	]
}
```

再单独创建一个babel.config.js文件(把options配置项取出来)

```js
module.exports={
  exclude: /node_modules/, 
  presets: ['@babel/preset-env'],
  plugins: [
    ['@babel/plugin-transform-runtime', {
      corejs: 3
    }]
  ]
}
```

经测试，corejs3 目前不支持fetch的编译

**3.也可以不使用plugin-transform-runtime和runtime-corejs3，直接使用core-js@3进行垫片处理**

 仅下载core-js@3:   npm i core-js@3 -D

配置babel.config.js

```js
module.exports={
  exclude: /node_modules/, 
  presets: ['@babel/preset-env'], {
    useBuiltIns: 'usage', //按需加载api补丁
     corejs: 3
  }]
}
```

对比发现，使用plugin-transform-runtime和使用corejs的区别在于：

+ plugin-transform-runtime和runtime-corejs3把所有处理的方法涉及到的变量转化成了处理后的方法处理

+ 直接使用corejs则尽量保持原变量名，通过全局垫片方式实现方法，如果是类似async、await这种没有办法使用全局变量实现的方法，也还是换转化成处理后的的语法实现
+ 直接使用corejs会污染全局变量，对于正常的项目来说没有什么影响，但是如果是开发一个库，可能会有所影响

**4. class的装饰器语法需要安装Babel插件 @babel/plugin-proposal-decorators** 

注意：

1. 如果和@babel/plugin-proposal-class-properties同时使用，要把@babel/plugin-proposal-decorators放前面

2. 如果需要是用旧的提案第一阶段的语法，需要设置legacy为true，同时设置插件@babel/plugin-proposal-decorators的loose为true

   ```js
    plugins:[
      [
        "@babel/plugin-proposal-decorators",//支持class装饰器语法
        {"legacy":true}//使用旧的第一阶段的语法
      ],
      [ 
        "@babel/plugin-proposal-class-properties",//支持class相关的新的语法的插件
        {"loose":true}//宽松语法模式
      ]
   ]
   ```

   [扩展：了解ECMA标准提案的几个阶段stage-x](https://www.cnblogs.com/qiqingfu/p/12387591.html)

   babel的配置中

+ plugins是优先于presets执行的
+ plugins中执行顺序是从上到下
+ presets中执行顺序是从下往上

