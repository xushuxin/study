1. 工厂模式：定义一个工厂方法，然后通过调用这个方法拿到想要的对象

   ```js
   (function(){
     function jQuery(selector){
     	return new jQuery.fn.init(selector)
     } 
     jQuery.fn.init.prototype = jQuery.fn;
     jQuery.fn = jQuery.prototype = {//原型重定向，批量添加属性方法
       init:function(){}
     }
     window.$ = window.jquery = jQuery;//暴露出去的是工厂函数
   })(window)
   ```

   技巧：

   + window当做实参传入，减少作用域链查找

   好处：

   + 简化调用方式 `new $('selector') => $('selector')`

   什么时候用：

   + 当轮子需要大量产出对象

2. 建造者模式

   + 类，功能复杂，参数庞大

   + 将类相关功能拆分成多个模块，最后堆砌到一起

     

3. 为什么vue3改为函数式

   + 支持tree-shaking：删除没有用到方法（原理：跟踪export文档流）

   + 面向对象没有办法做到内部方法的tree-shaking的（不知道哪个函数用没有调用）

     vue中使用export 导出大量函数，使用时，通过解构方式导入，没有导入的其他方法不会打包

   

4. 单例模式

   + 保证全局对象只有一个

   应用：

   vuex、vue-router

   代码示例：

   ```js
   var _vue;//使用Vue类自身和installed属性保证方法值在同一个Vue上只调用一次
   function install(vue){
   	if(_vue === vue &&install.installed) return;
     _vue = vue;
     install.installed = true;
   }
   ```

5. 装饰者模式

   保证原功能不变，添加一些额外功能

   应用：vue对于数组的处理

   ```js
   var arr = ['push','pop'];
   var arrProto = Array.prototyope;
   var arrMethods = Object.create(arrayProto);
   arr.forEach((method)=>{
     //重写指定数组方法
     arrayMethods[method] = function(){
       var origin = arrayProto[method];
       var result = origin.apply(this,args);//调用原数组方法，保证功能不变
       dep.notify();//通知更新（额外功能）
       return result;
     }
   })
   ```

6. 享元模式

   ```js
   $.extend = function(){
     //把相同的数据提取出来，减少
   	var target = this;
     var source = arguments[0];
   	if(arguments.length == 2){
       target = arguments[0];
       source = arguments[1];
     }
     for(var itme in source){
       target[item] = source[item]
     }
   }
   ```

   