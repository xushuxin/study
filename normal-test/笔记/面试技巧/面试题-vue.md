#### 框架与库的区别

**框架**定义了一套语法规则，用户根据语法书写代码，框架会按照规则解析编译成原生的语法

**库**是内部封装了一套方法，用户可以按照库定义的接口直接调用这些方法



#### vue中使用了scoped，父子组件怎么共享样式？

父组件本来只可以修改子组件最外层的样式，使用vue-loader提供的 /deep/ 组合器可以修改组件内部的样式



#### vue中使用了scoped，怎么给body设置样式？

通过动态添加移除类名的方式，beforeCreate钩子函数中给body添加类名，设置样式，destroyed的时候移除类名



#### v-show和v-if的区别

**v-show**：只是css的显示和隐藏

**v-if**：是元素的添加和移除

v-if有更高的切换开销，而v-show有更高的初始渲染开销；

因此，如果需要非常频繁地切换，使用v-show比较好，如果运行时条件很少改变，则使用v-if比较好。



#### Vue中key的作用

1. 是元素和组件的唯一标识
2. 可以防止元素复用
3. 可以提升diff算法的效率

理想的key应该是一个唯一的id



#### 为什么v-for和v-if不建议一起使用

v-for的优先级高于v-if，这样每一项都需要做v-if判断，会造成性能浪费

代替方案：使用computed属性，返回一个过滤后的数组

好处：

- 过滤后的列表*只*会在数组发生相关变化时才被重新运算，过滤更高效。
- 使用 计算属性之后，我们在渲染的时候*只*遍历需要渲染的元素，渲染更高效。
- 解耦渲染层的逻辑，可维护性更强。



#### 用数组索引作为key会有什么缺陷

删除元素时，会造成数组塌陷，元素复用



#### Vue视图不更新问题

**对象：**

1. $set设置对象或者数组的属性值
2. 添加对象属性后，使用$forceUpdate() 触发视图更新
3. 添加对象属性后，浅拷贝重新赋值给原来保存对象的属性

**数组：**

多一个：手动调用数组的splice方法触发视图更新（$set内部也是这么做的）

#### Vue中的修饰符

**事件修饰符**

**.stop 阻止事件冒泡**

**.prevent 阻止事件的默认行为**

**.native 为组件的根元素绑定原生事件**

**.once 事件只会触发一次**

**.sync 自定义事件和$emit的语法糖**

.capture 添加事件监听器时使用事件捕获模式（即内部元素触发的事件先在此处理，然后再交由内部元素进行处理）

.self 仅当event.target是绑定该修饰符元素自身时才会触发事件（即事件不是内部元素触发的）

.passive 滚动事件的默认行为(即滚动行为)会立即触发，而不会等待绑定的事件执行完成，也会忽略event.preventDeafult()，尤其能够提升移动端的性能



#### 计算属性computed

计算属性是依赖其他变量的计算结果，只要是在get函数中**同步编写**的变量，都是当前计算属性的依赖；只有依赖发生改变时，当前get函数才会被重新调用，返回新的计算属性值。

如果需要修改计算属性的值，需要设置set函数，并在set函数中修改当前计算属性的依赖，从而再次触发get函数，重新计算。



#### Vue组件中data为什么必须是一个函数

为了保证在组件复用时数据的独立性。

如果data使用对象，则复用组件时，多个实例会共享一个对象



#### package.lock.json的作用

锁定依赖的版本号，防止下载高于当前版本的依赖



#### 为什么Vue的DOM更新是异步的？

为了节省性能，连续多次修改数据，放到一起更新一次DOM



#### $nextTick的原理

利用浏览器的event loop，异步任务会在dom更新之后执行，采用微任务优先原则，不支持微任务才去采用宏任务

(如果调用$nextTick时没有传递函数，并且支持Promise，则先返回一个pending状态的promise，等执行回调时把该promsie状态改为成功态)

优先顺序：Promise（微任务）=>MutationObserver（微任务）=>setImmediate（宏任务）=>setTimeout（宏任务）



#### 组件间数据交互

**父子组件之间的数据交互**：

最常用的方式是：

1. 自定义属性 + props 和 自定义事件 + $emit

 其他的还有：

2. $parent获取父组件 + $children 或者 ref 获取子组件

3. $attrs接收的是父组件传递给子组件的没有被props接收的那些属性（数据没有响应式）；

   $listeners接收的是父组件传递的自定义事件(不含 `.native` 修饰器)
   
4. provide & inject 父组件提供的数据，后代组件都可以通过inject注入使用，一般使用在高价组件或者插件中（数据没有响应式）
   

**跨组件传参**   

5. eventBus 创建一个空的Vue实例，通过$on,$emit,$off来实现组件间数据交互

6. vuex 最常用的跨组件传参方式

**为啥没有响应式父组件修改了绑定的值，子组件也会更新？**

因为父组件数据发生修改，会更新页面，子组件的内容也会被更新

#### 父子组件生成及销毁的顺序

**生成**：

父beforCreate=>父created=>父beforeMount=>子beforeCreate=>子created=>子beforeMount=>子mounted=>父mounted

**子组件触发事件，父组件修改数据更新：**

父beforeUpdate => 儿子beforeUpdate => 儿子updated  => 父updated

**销毁：**

父beforeDestroy=>子beforeDestroy=>子destroyed=>父destroyed

**生成和销毁子组件之前都会触发父组件的beforeUpdate，子组件mounted或者destroyed会触发父组件的updated**

![image-20201214163331934](/Users/xushuxin/Library/Application Support/typora-user-images/image-20201214163331934.png)![image-20201214163412987](/Users/xushuxin/Library/Application Support/typora-user-images/image-20201214163412987.png)

注：父组件mounted可以拿到子组件以及dom元素，ref如果获取的是组件，可以通过$el属性获取到对应的根元素

#### Vue性能优化

1. data尽量扁平化处理（Vue的数据劫持方面优化，Vue会对对象递归劫持）
2. 不需要修改的数据使用Object.freeze冻结处理
3. v-if和v-show区分使用场景（v-if有更大的切换开销，v-show有更大的初始化开销）
4. v-for循环时，注重key的作用
5. 对于没有使用vue语法的模块，用v-pre指令来提升编译效率(跳过元素和它的子元素的编译过程)
6. 长列表不去直接渲染，而是通过虚拟列表去展渲染 插件  -----  vue-virtual-scroll-list
7. 组件懒加载+骨架屏 优化首屏加载速度
8. 图片懒加载  插件--- vue-lazyload
9. 对于切换时不用销毁的组件采用keep-alive进行缓存
10. ui组件库按需加载
11. 使用alias 减小文件搜索范围，提升编译效率

#### v-model的原理

v-model本质上是v-bind和v-on的语法糖

在输入框上使用value和input事件；

在checkbox和radio使用checked属性和change事件

在select

#### Vue2的响应式原理

每个组件实例都对应一个watcher实例，它会在组件渲染过程中把“接触”过的数据property记录为依赖，之后当依赖的setter触发时，会通知watcher，从而把它关联的组件重新渲染。

#### 说说你对SPA单页面的理解，它的优缺点分别是什么？

 单页面只有一个html页面，用户看到的不同“页面“，都是通过路由机制实现html内容替换，一般首次都会把公共的js，css资源加载，然后，单个功能页面的资源可以通过路由懒加载按需加载。

优点：

	1. 页面切换快，用户体验好，内容改变不需要重新加载页面，避免了重复渲染
 	2. 基于第一点，单页应用对服务器的压力小
 	3. 前后端分离，架构清晰，有利于维护

缺点：

	1. 首次加载时可能耗时较长
 	2. 不能使用浏览器的前进后退功能，所有页面的切换需要自己建立堆栈管理
 	3. 不利于SEO