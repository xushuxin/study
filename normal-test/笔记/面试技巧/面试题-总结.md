#### HTML5有哪些新特性

+ 语义标签 <article>、<header>、<section>、<aside>、<footer>、<nav>

  还有main、progress、time、data等元素标签

  好处：有利于开发和维护；统一标准，减少不同浏览器之间的兼容问题

+ Canvas、SVG、WebGL
+ 视频和音频  <video>和<audio>
+ 表单的增强，更多的表单类型【email、date、serach、tel等】以及表单校验【required（必输字段） pattern（正则表达式校验）、maxlength、minlength】
+ DOM存储(web storage)：localStorage（持久存储）、sessionStorage(会话存储)
+ 本地数据库存储 IndexedDB
+ 通过input type=”file"访问本地文件
+ 拖放事件及API
+ Web Worker  把 JavaScript 计算委托给后台线程处理，减少运行卡顿
+ requireAnimationFrame 提高js动画性能
+ 在线离线事件：online、offline
+ WebRTC实时通信技术

#### css选择器有哪些？哪些属性可以继承？优先级算法如何计算？

**选择器：**id选择器，类选择器，标签选择器，相邻选择器，子选择器，后代选择器，通配符选择器，属性选择器，伪类选择器

**可以继承的样式：**font-size，font-weight，font-family，font-style，line-height，text-align，color，text-indent，word-break，word-spacing，letter-spacing，white-space

**不可继承的样式**：比如border，padding，margin，width，height等等

**选择器优先级**：!important > 内联样式 >  id > class > 标签

选择器累加计算权重，权重高的生效；相同权重，后面加载的样式会覆盖前面的



#### position的值，relative和absolute分别是相对于谁定位的？

absolute：绝对定位，相对于最近一级的position不是static的父元素定位(如果没有则相对浏览器窗口定位)

relative：相对定位，相对于其正常文档流中的位置进行定位

fixed：相对于浏览器窗口定位

static:默认值，未定位，出现在正常文档流中



#### CSS3有哪些新特性？

+ CSS3实现圆角（border-radius），阴影(box-shadow)，文字特效（text-shadow）、线性渐变（gradient）、过渡（transition）、动画（animations）
+ 媒体查询

+ 多栏布局（multi-columns）、弹性布局（flexible box）、网格布局（grid layouts）

+ 边框图片（border-image）

+ 选择器：子串匹配的属性选择器，伪元素改为使用两个冒号开头

+ **css3新增伪类选择器举例：**

  p:first-of-type 选择属于其父元素的第一个p元素的每个p元素

  p:last-of-type 选择属于其父元素的最后一个p元素的每个p元素

  p:only-child 选择属于其父元素的唯一p元素的每个p元素

  p:nth-child(2) 选择属于其父元素的第2个p元素的所有p元素

  :enabled :disabled 表单元素启用/禁用状态

  :checked 单选框/复选框选中状态

#### CSS中的link和@import的区别是什么？

+ link属于html标签只能在html中使用，@import是css提供的，用于css文件或者style标签中
+ 页面加载时，link引用的资源会同时加载，而@import引用的资源会在页面加载完成之后再加载
+ link是HTML标签，无兼容问题；@import是css2的特性，ie5以上才支持
+ link方式的样式的权重高于@import的权重



#### 如何解决延迟倒计时抢购问题？

首先，可以使用HEAD请求，AJAX状态为2获取响应头中的时间信息（xhr.getResponseHeader('Date')），

然后通过目标时间减去服务器事件计算出剩余时间；

后续利用setInterval每隔一秒把剩余时间减去1s，再展示到页面上



#### 什么是BFC？

BFC(Block Formatting Contexts)，块级格式化上下文，是页面盒模型布局中的一种css渲染模式，相当于一个独立容器，里面的元素和外部的元素互不影响。

创建BFC的方式：

1. 根元素(html标签)

2. 浮动元素（元素的 float 不是 none）

3. 绝对定位/固定定位元素（元素的 position 为 absolute 或 fixed）

4. 行内块元素（元素的 display 为 inline-block）
5. 表格单元格（元素的 display为 table-cell）
6. 弹性元素（display为 flex 或 inline-flex元素的直接子元素）
7. 网格元素（display为 grid 或 inline-grid 元素的直接子元素）
8. overflow 值不为 visible 的块元素

BFC的特点：

1. 内部的盒子在垂直方向上时一个一个放置的

2. 内部的盒子垂直方向的距离是由margin决定的，并且相邻块级盒子的垂直外边距会产生折叠
3. BFC区域计算高度时，浮动元素也会参与  => 解决浮动元素父元素高度塌陷问题
4. 形成BFC的区域不会与外部的浮动元素重叠  =>实现左图右文，文字不会环绕图片
5. BFC区域与外部元素互不影响，也就是说，垂直外边距不会折叠。=>解决上下外边距折叠问题

#### IFC

IFC（inline Formatting Context）叫做“行级格式化上下文”
局规则如下：
1.内部的盒子会在水平方向，一个个地放置；
2.IFC的高度，由里面最高盒子的高度决定；
3.当一行不够放置的时候会自动切换到下一行；

#### GFC

GFC(GridLayout Formatting Contexts)意为“网格布局格式化上下文”

当一个元素设置为display:grid的时候，此元素将获得一个独立的渲染区域，可以在网格容器上定义网格行和列，为每一个网格定义位置和空间。GFC和table的区别在于GridLayout会有更加丰富的属性来控制行列，控制对齐以及更为精细的渲染。

#### FFC

FFC(Flex Formatting Contexts)意为“自适应格式化上下文”

display值为flex或者inline-flex的元素将会生成自适应容器。flex box由伸缩容器和伸缩子元素组成。通过设置元素display:flex/inline-flex可以得到伸缩容器，前者为块级元素，后者为行内元素。伸缩容器外元素不受影响。

#### 为什么TCP是三次握手而不是两次或者四次

主要是为了建立相对稳定的连接，保证数据的可靠传输的同时也要提高传输的效率。如果只握手两次，只能让客户端确认服务器端的状态，某些客户端已经视为失效的请求，又发到了服务端，这时候服务器端不能确认客户端状态，仍然会建立连接，造成不必要的资源浪费。而第三次握手可以让服务器端确认客户端的状态，避免建立不必要的连接。



#### 浏览器输入一段url之后做了哪些事？

+ 先进行DNS域名解析查找ip地址，如果有DNS缓存，直接获取缓存中的ip（1.浏览器DNS缓存2.本地DNS缓存 3.本地hosts文件映射4.路由器DNS缓存5.到互联网服务提供商(ISP)的DNS服务器查询 6.根服务器递归查询）
+ 发起tcp三次握手，建立tcp连接
+ 发送请求，如果是https请求还需要建立SSL连接
+ 服务器端处理请求返回数据
+ tcp4次挥手关闭连接
+ 浏览器解析服务器返回的HTML，构建DOM树，并且请求解析过程中遇到的js、css等资源文件
+ CSS资源下载完成后，解析CSS，构建CSSOM树
+ 将DOM树和CSSOM树合并成一个渲染树
+ 根据渲染树来布局，计算每个节点在页面坐标系中的大小和位置
+ 最后调用GPU绘制，合成图层，显示在屏幕上



#### HTTP缓存

**强缓存**：首次请求资源时，把获取到的资源存储到本地，下一次请求资源时，首先查看本地是否有缓存，有缓存并且没有失效，则直接从本地缓存中获取

通过设置响应头expires或者cache-control来实现，cache-control的优先级高于expires

expires：资源失效时间，使用服务器时间，可能会由于客户端时间和服务器时间不同而导致缓存混乱

cache-control：

​	max-age 设置了资源的有效时间，是一个相对时间；

​	no-cache 表示不直接使用本地缓存，而是先去服务器端校验缓存是否失效（也就是使用协商缓存）

​	no-store 表示不本地存储缓存，直接获取最新资源（强缓存和协商缓存都不用）

​	public/private  public表示允许代理服务器缓存资源，private表示仅允许客户端缓存资源

**协商缓存**：如果没有命中强缓存，则服务器会发送请求到服务器，验证资源是否更新，没有更新继续使用本地缓存，更新了则使用服务器返回的最新资源

通过设置响应头last-modified或者etag实现，一起使用时etag优先级更高

1.last-modified 

last-modified记录服务器资源最后修改时间，启用后，请求资源的响应头会增加一个last-modified字段；再次请求资源时，请求头会带有if-modified-since字段，值是之前返回的last-modified的值，服务器端会对比该字段和资源的最后修改时间，如果一致，则返回304，浏览器直接使用缓存，如果不一致则返回修改后的资源，并修改last-modified的值

2.由于last-modified记录资源的修改时间只能精确到秒，还是不够精确，所以又出现了etag

etag:可以保证每个资源是唯一（通过文件的编号，最后修改时间，大小多个因子，使用抗碰撞散列函数来生成的，重复的概率小到可以忽略）

服务器端通过上送请求头中的if-none-match（值是上一次返回的etag的值）来和资源生成的etag作对比，判断资源是否已修改。



#### Object.create的原理

Object.create创建一个新对象，并用指定对象作为新对象的原型

```js
Object.create = function(pro) {
  var Anonymous = (function() {
    return function() {};
  })();
  Anonymous.prototype = pro;
  return new Anonymous;
}
```

创建一个匿名函数，把匿名函数的prototype设置为传入的对象，最后使用new创建匿名函数的实例并返回



#### 说一说微任务和宏任务的区别

微任务执行的优先级高于宏任务，每次event loop都会清空一次微任务队列，然后再去执行下一个宏任务，而每个宏任务都会触发一次event loop

