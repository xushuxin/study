#### HTML5有哪些新特性

+ 语义标签 `<article>、<header>、<section>、<aside>、<footer>、<nav>`

  还有main、progress、time、data等元素标签

  好处：有利于开发和维护；统一标准，减少不同浏览器之间的兼容问题

+ Canvas、SVG、WebGL
+ 视频和音频  `<video>`和`<audio>`
+ 表单的增强，更多的表单类型【email、date、serach、tel等】以及表单校验【required（必输字段） pattern（正则表达式校验）、maxlength、minlength】
+ DOM存储(web storage)：localStorage（持久存储）、sessionStorage(会话存储)
+ 本地数据库存储 IndexedDB
+ 通过input type=”file"访问本地文件
+ 拖放事件及API
+ Web Worker  把 JavaScript 计算委托给后台线程处理，减少运行卡顿
+ requireAnimationFrame 提高js动画性能
+ 在线离线事件：online、offline
+ WebRTC实时通信技术

#### css选择器有哪些？哪些属性可以继承？优先级算法如何计算？

**选择器：**id选择器，类选择器，标签选择器，相邻选择器，子选择器，后代选择器，通配符选择器，属性选择器，伪类选择器

**可以继承的样式：**font-size，font-weight，font-family，font-style，line-height，text-align，color，text-indent，word-break，word-spacing，letter-spacing，white-space

**不可继承的样式**：比如border，padding，margin，width，height等等

**选择器优先级**：!important > 内联样式 >  id > class > 标签

选择器累加计算权重，权重高的生效；相同权重，后面加载的样式会覆盖前面的



#### position的值，relative和absolute分别是相对于谁定位的？

absolute：绝对定位，相对于最近一级的position不是static的父元素定位(如果没有则相对浏览器窗口定位)

relative：相对定位，相对于其正常文档流中的位置进行定位

fixed：相对于浏览器窗口定位

static:默认值，未定位，出现在正常文档流中



#### CSS3有哪些新特性？

+ CSS3实现圆角（border-radius），阴影(box-shadow)，文字特效（text-shadow）、线性渐变（gradient）、过渡（transition）、动画（animations）
+ 媒体查询

+ 多栏布局（multi-columns）、弹性布局（flexible box）、网格布局（grid layouts）

+ 边框图片（border-image）

+ 选择器：子串匹配的属性选择器，伪元素改为使用两个冒号开头

+ **css3新增伪类选择器举例：**

  p:first-of-type 选择属于其父元素的第一个p元素的每个p元素

  p:last-of-type 选择属于其父元素的最后一个p元素的每个p元素

  p:only-child 选择属于其父元素的唯一p元素的每个p元素

  p:nth-child(2) 选择属于其父元素的第2个p元素的所有p元素

  :enabled :disabled 表单元素启用/禁用状态

  :checked 单选框/复选框选中状态

#### CSS中的link和@import的区别是什么？

+ link属于html标签只能在html中使用，@import是css提供的，用于css文件或者style标签中
+ 页面加载时，link引用的资源会同时加载，而@import引用的资源会在页面加载完成之后再加载
+ link是HTML标签，无兼容问题；@import是css2的特性，ie5以上才支持
+ link方式的样式的权重高于@import的权重



#### 如何解决延迟倒计时抢购问题？

首先，可以使用HEAD请求，AJAX状态为2获取响应头中的时间信息（xhr.getResponseHeader('Date')），

然后通过目标时间减去服务器事件计算出剩余时间；

后续利用setInterval每隔一秒把剩余时间减去1s，再展示到页面上



#### 什么是BFC？

BFC(Block Formatting Contexts)，块级格式化上下文，是页面盒模型布局中的一种css渲染模式。

创建BFC的方式：

根元素(html标签)、浮动元素、绝对定位/固定定位元素、行内块元素、表格单元格、弹性元素、网格元素、overflow 值不为 visible 的块元素

BFC的特点：

1. BFC计算高度时，浮动元素也会参与  => 清除浮动
2. BFC与外部元素互不影响，因此不会产生垂直外边距重叠=>防止垂直外边距重叠
3. BFC不会与外部的浮动元素重叠  =>实现左图右文，文字不会环绕图片

#### IFC

IFC（inline Formatting Context）叫做“行级格式化上下文”
局规则如下：
1.内部的盒子会在水平方向，一个个地放置；
2.IFC的高度，由里面最高盒子的高度决定；
3.当一行不够放置的时候会自动切换到下一行；

#### GFC

GFC(GridLayout Formatting Contexts)意为“网格布局格式化上下文”

当一个元素设置为display:grid的时候，此元素将获得一个独立的渲染区域，可以在网格容器上定义网格行和列，为每一个网格定义位置和空间。GFC和table的区别在于GridLayout会有更加丰富的属性来控制行列，控制对齐以及更为精细的渲染。

#### FFC

FFC(Flex Formatting Contexts)意为“自适应格式化上下文”

display值为flex或者inline-flex的元素将会生成自适应容器。flex box由伸缩容器和伸缩子元素组成。通过设置元素display:flex/inline-flex可以得到伸缩容器，前者为块级元素，后者为行内元素。伸缩容器外元素不受影响。

#### 为什么TCP是三次握手而不是两次或者四次

主要是为了建立相对稳定的连接，保证数据的可靠传输的同时也要提高传输的效率。如果只握手两次，只能让客户端确认服务器端的状态，某些客户端已经视为失效的请求，又发到了服务端，这时候服务器端不能确认客户端状态，仍然会建立连接，造成不必要的资源浪费。而第三次握手可以让服务器端确认客户端的状态，避免建立不必要的连接。



#### HTTP几个版本之间的区别

http 0.9 负责传输html 最早的时候没有请求头 和响应头
http 1.0 提供了 http的header  根据header的不同来处理不同的资源
http 1.1 默认开启了keep-alive 链接复用  管线化 服务器处理多个请求 （队头阻塞问题）
http 2.0 用同一个tcp链接来发送数据 一个域名一个tcp (多路复用)  头部压缩 服务器可以推送数据给客户端
http 3.0 解决了tcp的队头阻塞问题 QUIC协议 采用了udp

#### 重排/回流与重绘

重绘：页面元素属性发生改变，不影响元素大小和布局，浏览器会重新绘制修改部分的样式（不需要重新构建渲染树）;

重排/回流（reflow）：页面元素大小或者布局发生改变，浏览器会重新构建受影响部分的渲染树。回流之后，会重新绘制受影响的部分（重绘），所以**回流一定会触发重绘**

总结：回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。

**会触发回流的操作:**
页面初次渲染
浏览器窗口大小改变
元素尺寸、位置、内容发生改变
元素字体大小变化
添加或者删除可见的 dom 元素
激活 CSS 伪类（例如：:hover）
查询某些属性或调用某些方法
clientWidth、clientHeight、clientTop、clientLeft
offsetWidth、offsetHeight、offsetTop、offsetLeft
scrollWidth、scrollHeight、scrollTop、scrollLeft
getComputedStyle()
getBoundingClientRect()
scrollTo()

**减少重排与重绘的一些要点:**

1：不要通过父级来改变子元素样式，最好直接改变子元素样式，改变子元素样式尽可能不要影响父元素和兄弟元素的大小和尺寸
2：尽量通过class来设计元素样式，不要用style
3：实现元素的动画，对于经常要进行回流的组件，要抽离出来，它的position属性应当设为fixed或absolute
4：权衡速度的平滑。比如实现一个动画，以1个像素为单位移动这样最平滑，但reflow就会过于频繁，CPU很快就会被完全占用。如果以3个像素为单位移动就会好很多。
5：不要用tables布局的另一个原因就是tables中某个元素一旦触发reflow就会导致table里所有的其它元素reflow。在适合用table的场合，可以设置table-layout为auto或fixed，
6：这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围。
7：css里不要有表达式expression
8：减少不必要的 DOM 层级（DOM depth）。改变 DOM 树中的一级会导致所有层级的改变，上至根部，下至被改变节点的子节点。这导致大量时间耗费在执行 reflow 上面。
9：避免不必要的复杂的 CSS 选择器，尤其是后代选择器（descendant selectors），因为为了匹配选择器将耗费更多的 CPU。
10: 尽量不要过多的频繁的去增加，修改，删除元素，因为这可能会频繁的导致页面reflow，可以先把该dom节点抽离到内存中进行复杂的操作然后再display到页面上。
11：请求如下值offsetTop, offsetLeft, offsetWidth, offsetHeight，scrollTop/Left/Width/Height，clientTop/Left/Width/Height，浏览器会发生reflow，建议将他们合并到一起操作，可以减少回流的次数。

#### HTTP缓存

**强缓存**：首次请求资源时，把获取到的资源存储到本地，下一次请求资源时，首先查看本地是否有缓存，有缓存并且没有失效，则直接从本地缓存中获取

通过设置响应头expires或者cache-control来实现，cache-control的优先级高于expires

expires：资源失效时间，使用服务器时间，可能会由于客户端时间和服务器时间不同而导致缓存混乱

cache-control：

​	max-age 设置了资源的有效时间，是一个相对时间；

​	no-cache 表示不直接使用本地缓存，而是先去服务器端校验缓存是否失效（也就是使用协商缓存）

​	no-store 表示不本地存储缓存，直接获取最新资源（强缓存和协商缓存都不用）

​	public/private  public表示允许代理服务器缓存资源，private表示仅允许客户端缓存资源

**协商缓存**：如果没有命中强缓存，则服务器会发送请求到服务器，验证资源是否更新，没有更新继续使用本地缓存，更新了则使用服务器返回的最新资源

通过设置响应头last-modified或者etag实现，一起使用时etag优先级更高

1.last-modified 

last-modified记录服务器资源最后修改时间，启用后，请求资源的响应头会增加一个last-modified字段；再次请求资源时，请求头会带有if-modified-since字段，值是之前返回的last-modified的值，服务器端会对比该字段和资源的最后修改时间，如果一致，则返回304，浏览器直接使用缓存，如果不一致则返回修改后的资源，并修改last-modified的值

2.由于last-modified记录资源的修改时间只能精确到秒，还是不够精确，所以又出现了etag

etag:可以保证每个资源是唯一（通过文件的编号，最后修改时间，大小多个因子，使用抗碰撞散列函数来生成的，重复的概率小到可以忽略）

服务器端通过上送请求头中的if-none-match（值是上一次返回的etag的值）来和资源生成的etag作对比，判断资源是否已修改。



#### Object.create的原理

Object.create创建一个新对象，并用指定对象作为新对象的原型

```js
Object.create = function(pro) {
  var Anonymous = (function() {
    return function() {};
  })();
  Anonymous.prototype = pro;
  return new Anonymous;
}
```

使用自执行函数创建一个匿名函数，把匿名函数的prototype设置为传入的对象，最后使用new创建匿名函数的实例并返回



#### 说一说微任务和宏任务的区别

微任务和宏任务都属于异步任务，只不过微任务执行的优先级高于宏任务，每次event loop都会清空一次微任务队列，然后再去执行下一个宏任务，而每个宏任务都会触发一次event loop



#### Ajax、Axios、fetch的区别？

+ Ajax 是基于XMLHttpRequest对象实现的前后端数据通信方案，

+ Axios是对Ajax的封装，基于Promise管理请求，解决回调地狱的问题

+ Fetch是ES6新增的通信方法，不是Ajax，但是它本身实现数据通信就是基于promise管理的

  ps：jQeury的$.ajax()是对于ajax基于回调函数方式的封装



#### 什么是同源策略？

首先，同源指的是：协议，域名，端口三者都相同。

而同源策略则指的是浏览器对于非同源脚本、文件的限制访问。



#### 谈一谈mouseover和mouseenter的区别？

+ mouseover 

  + 存在冒泡传播机制

  + 忽略元素层级关系，鼠标划入子元素也算划出父元素，划出子元素也算划入父元素

+ mouseenter 
  + 默认阻止了事件的冒泡
  + 存在元素层级关系，鼠标进入子元素，不算离开父元素，鼠标离开子元素不算进入父元素







