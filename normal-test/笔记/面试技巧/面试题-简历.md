#### 1.你工作中用到过哪些ES6语法？

let、const、解构赋值、扩展运算符、Promise、async/await、Set和Map数据结构、for..of循环（只能遍历具有Iterator接口的数据结构）、Generator函数（async/await的原理可以用Generator函数配合Promise实现）、Class

还有比如数组的

实例方法：find,includes,flat

静态方法：Array.from	Array.of(将一组数转为数组)

对象的静态方法：

Object.is（与三个等号的区别是①+0和-0不相等②NaN等于NaN）

Object.assign 将一个或多个对象的所有可枚举属性(包含Symbol属性)复制到目标对象

Object.keys  Object.values Object.entries

Object.fromEntries  entries的逆操作，将一个键值对数组转为对象

#### 2.webpack你都做过哪些方面的优化？

```js
1-利用externals提取第三方依赖并用CDN引入

2-利用splitChunks提取公共js代码和分割js代码

3-使用 DllPlugin 和 DllReferencePlugin分离出不需要更新变动的包

4-使用require.context批量注册全局组件

5-使用ProvidePlugin自动导入模块

6-resolve.modules和resolve.alias设置绝对路径别名，减小文件搜索范围

7-利用image-webpack-loader进行压缩图片

8-thread-loader多进程打包

9-使用@babel/plugin-transform-runtime解决语法转换时生成重复冗余代码的问题

10-resolve.noParse，减少不必要的解析

11-动态导入的方式，减小首次加载包的体积

```

**开发效率方面**

1 .之前我们注册全局组件，都是通过一个一个手动引入，后面做了优化，利用webpack的require.context把所有的组件一次性导入注册，后续添加组件也不需要再自己手动注册了（注册路由、还有Vuex中的模块导入也应用到了）

2 .使用webpack提供的providePlugin可以实现包的自动引入，比如我们的项目是多页面的，每个页面都需要引入Vue，我就通过providePlugin,把Vue设置成自动引入了；providePlugin不仅能自动引入node_modules中的包，我们自己的js文件，甚至是对象的一个属性也可以设置自动导入（只需要符合commonjs或者ESModule的导出规范），比如我们项目基于axios二次封装了一下，然后通过ProvidePlugin把它的post和get请求都设置成自动引入，调用时就直接使用post，get就可以了

**性能及构建方面**

1 .通过webpack的externals配置把vue和element-ui抽离出来，使用CDN方式引入，加快了页面加载速度以及打包构建速度（其实通过webpack的splitChunks和动态链接库也可以实现分包，只不过我们觉得CDN方式加载会更好一点，所以就没有使用了）。

2 .利用动态导入的方式减小首次加载时的包的体积

2 .尽量使用webpack的alias设置绝对路径的别名去引入文件，有利于加快构建速度

3 .使用modules配置项，让我们可以像引入npm包一样引入自己的js文件，并且设置了绝对路径也能加快打包的速度