啊哈算法-第4章 第3节

```js
//广度优先搜索来查找迷宫的最优解
//每走一步，把当前步可扩展的坐标记录下来，如果可扩展的坐标中出现终点，则停止搜索
function getMinimum(n, m, map, startX, startY, endX, endY) {
  //创建一个队列维护当前坐标及扩展的坐标（n,m<50,所以队列长度不会超过2500,坐标从1开始，所以是2501)
  let que = new Que(2501),
 			book=Array(51).fill(undefined).map(item=>Array(51).fill(0));//记录已走过的坐标
  let next = [//四种走法
    [0,1],//向右
    [1,0],//向下
    [0,-1],//向左
    [-1,0]//向上
  ];
  //初始化队列
  let head =1,tail=1;
  que[tail].x = startX;
  que[tail].y = startY;
  que[tail].s = 0;
  tail++;
  book[startX][startY] = 1;

  //从队头向队尾遍历
  while(head<tail){
    //枚举四种走法
    for(var i=0;i<=3;i++){
      //计算每一种走法后的坐标
      tx = que[head].x + next[i][0];
      ty = que[head].y + next[i][1];
      
      //判断坐标是否越界
      if(tx<1||tx>n||ty<1||ty>m) continue;

      //如果不是路障，并且未走过
      //向队尾添加该坐标
      if(map[tx-1][ty-1] === 0 && book[tx][ty] === 0){
        que[tail].x = tx;
        que[tail].y = ty;
        que[tail].s = que[head].s+1;//到达该坐标需要的步数为队头需要的步数加1
        tail++;
      }

      //如果扩展点为目标点
      if(tx === endX && ty === endY){
        return que[tail-1].s;//返回到达目标需要的步数
      }
    }
    head++;//当前队头可扩展点添加到队列后，移动队头，对下一个坐标进行扩展
  }
  
}
class Que{
  constructor(num){
    return new Array(num).fill(undefined).map(item=>({
      x:undefined,//x坐标
      y:undefined,//y坐标
      s:undefined,//步数
    }))
  }
}
console.log(getMinimum(
  5, 4, //行列
  [ //地图
    [0, 0, 1, 0],
    [0, 0, 0, 0],
    [0, 0, 1, 0],
    [0, 1, 0, 0],
    [0, 0, 0, 1],
  ],
  1, 1, //起始点坐标
  4, 3 //目标点坐标
))
```

