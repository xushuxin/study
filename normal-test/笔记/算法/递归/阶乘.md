##### 递归求阶乘

```js
"use strict";
function factorial(n){
  if(n===0) return 1;
  return n * factorial(n-1);
}
console.log(factorial(6))
```

##### 尾递归求阶乘

+ 如果一个函数返回的是自己的调用结果就被称为尾递归
+ 默认浏览器和node都关闭了尾递归优化，主要是因为会**导致堆栈丢失**,所以正常用尾递归还是会堆栈溢出

```js
function factorialTrail(n,total = 1){
  if(n===0) return total;
  return factorialTrail(n-1, n*total)
}
console.log(factorialTrail(10000))//堆栈溢出
```

##### 可以开启严格模式，并且通过弹跳床函数解决尾递归的堆栈溢出问题

```js
"use strict";
//弹跳床函数，只要是函数就会执行函数获取结果
function trampoline(fn){
  while(typeof fn ==='function'){
    fn = fn();
  }
  return fn;
}
//实际的函数需要返回一个函数
function factorial3(n,total = 1n ){
  n = BigInt(n);
  if(n === 0n) return total;
  return factorial3.bind(null,n-1n,BigInt(n*total))
}
console.log(trampoline(factorial3(10000)))//不会堆栈溢出
```

