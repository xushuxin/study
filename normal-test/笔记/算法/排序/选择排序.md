复杂度：时间：O(n²) 	空间：O(1)

**相比于冒泡排序的优势**：交换次数比冒泡排序少多了，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快

思路：

+ 遍历数组length-1次，每次循环，假设当前项是最小项，和后续每一项进行比较，比较出本次循环最小的数的索引
+ 每次比较结束后，把比较出的最小数和当前项比较，如不相等，则进行交换位置
+ 每次都是把最小项放到当前项，遍历结束则数组变为从小到大排列

```js
function selectionSort(arr) {
  var len = arr.length;
  var minIndex, temp;
  for (var i = 0; i < len - 1; i++) {
    minIndex = i;
    for (var j = i + 1; j < len; j++) {
      if (arr[j] < arr[minIndex]) {     // 寻找最小的数
        minIndex = j;                 // 将最小数的索引保存
      }
    }
    if(arr[i] !== arr[minIndex]){//当前和选择的最小数不相等，交换
     	temp = arr[i];
      arr[i] = arr[minIndex];
      arr[minIndex] = temp; 
    }
  }
  return arr;
}
var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 04];
console.log(selectionSort(arr))
```



