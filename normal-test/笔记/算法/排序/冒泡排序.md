复杂度：时间：O(n²) 	空间：O(1)

思路：

+ 一次冒泡：遍历数组一次，当前项与下一项进行比较，如果大于下一项，交换两者位置，一次冒泡后数组中的最大值成为最后一项
+ 数组有n项，则进行n-1次遍历即可
+ 优化：冒泡过n次后，则已经有n个数已经在正确位置，冒泡时可以排除这些已经排序完成的数

```js
function bubblingSort(arr){
  for(var i= 0;i<arr.length-1;i++){
    for(var j = 0;j<arr.length-i;j++){
      if(arr[j]>arr[j+1]){
        let temp =arr[j+1];
        arr[j+1] = arr[j];
        arr[j] = temp;
      }
    }
  }
  return arr;
}
var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 04];
console.log(bubblingSort(arr));
```

