复杂度：时间：O(nlogn) 	空间：O(logn)

思路：

+ 只有不超过一项，则直接返回原数组
+ 获取中间的那个数，从数组中移除，并获取到值(为了不修改原数组，浅拷贝一份数组)
+ 创建两个数组left，right，遍历数组，小于中间值的放入left,大于中间值的放入right
+ 对left和right进行深度递归，一直到每个区间都只剩一个值,最后合并到一起

```js
function quickSort(ary){
  if(ary.length<=1) return ary;
  let arr = ary.slice();
  let center  = arr.splice(Math.floor(arr.length/2),1)[0];
  let left=[],right = [];
  for(var i = 0;i<arr.length;i++){
    if(arr[i]<center){
      left.push(arr[i]);
    }else{
      right.push(arr[i])
    }
  }
  return quickSort(left).concat(center,quickSort(right))
}
var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 04];
console.log(quickSort(arr));
console.log(arr);
```

