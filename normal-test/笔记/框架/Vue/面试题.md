#### 框架与库的区别

**框架**定义了一套语法规则，用户根据语法书写代码，框架会按照规则解析编译成原生的语法

**库**是内部封装了一套方法，用户可以按照库定义的接口直接调用这些方法



#### v-show和v-if的区别

**v-show**：只是css的显示和隐藏

**v-if**：是元素的添加和移除

v-if有更高的切换开销，而v-show有更高的初始渲染开销，因此，如果需要非常频繁地切换，使用v-show比较好，如果运行时条件很少改变，则使用v-if比较好。



#### Vue中key的作用

1. 是元素和组件的唯一标识
2. 可以防止元素复用
3. 可以提升diff算法的效率

理想的key应该是一个唯一的id



#### 为什么v-for和v-if不建议一起使用

v-for的优先级高于v-if，每一项都需要做v-if判断，会造成性能浪费

代替方案：使用computed属性，返回一个过滤后的数组

好处：

- 过滤后的列表*只*会在数组发生相关变化时才被重新运算，过滤更高效。
- 使用 计算属性之后，我们在渲染的时候*只*遍历需要渲染的元素，渲染更高效。
- 解耦渲染层的逻辑，可维护性更强。



#### 用数组索引作为key会有什么缺陷

删除元素时，会造成数组塌陷，元素复用



#### Vue视图不更新问题

对象：

 	1. $set设置对象或者数组的属性值
 	3. 添加对象属性后，使用$forceUpdate() 触发视图更新
      	3. 添加对象属性后，浅拷贝重新赋值给原来保存对象的属性

数组：

多一个：手动调用数组的splice方法触发视图更新（$set内部也是这么做的）

#### Vue中的修饰符

**事件修饰符**

.stop 阻止事件冒泡

.prevent 阻止事件的默认行为

.capture 添加事件监听器时使用事件捕获模式（即内部元素触发的事件先在此处理，然后再交由内部元素进行处理）

.self 仅当event.target是绑定该修饰符元素自身时才会触发事件（即事件不是内部元素触发的）

.once 事件只会触发一次

.passive 滚动事件的默认行为(即滚动行为)会立即触发，而不会等待绑定的事件执行完成，也会忽略event.preventDeafult()，尤其能够提升移动端的性能

.sync 自定义事件和$emit的语法糖

.native 为组件的根元素绑定原生事件



#### 计算属性computed

计算属性是依赖其他变量的计算结果，只要是在get函数中**同步编写**的变量，都是当前计算属性的依赖；只有依赖发生改变时，当前get函数才会被重新调用，返回新的计算属性值。

如果需要修改计算属性的值，需要设置set函数，并在set函数中修改当前计算属性的依赖，从而再次触发get函数，重新计算。



#### Vue组件中data为什么必须是一个函数

为了在组件复用的同时保证数据的独立



#### package.lock.json的作用

锁定依赖的版本号，防止下载高于当前版本的依赖



#### 为什么Vue的DOM更新是异步的？

为了节省性能，连续多次修改数据，放到一起更新一次DOM



#### $nextTick的原理

利用异步任务会在dom更新之后执行实现，创建空数组，执行$nextTick时，向数组中添加函数，然后优先利用微任务，等到dom更新之后执行数组中所有的函数，不支持微任务则使用宏任务代替

(如果调用$nextTick时没有传递函数，并且支持Promise，则先返回一个pending状态的promise，等执行回调时把该promsie状态改为成功态)

优先顺序：Promise =>MutationObserver=>setImmediate=>setTimeout

#### 组件间数据交互

**父子组件之间的数据交互**：

最常用的方式是：

1. 自定义属性 + props 和 自定义事件 + $emit

 其他的还有：

2. $parent + $children 或者 ref 获取组件

3. $attrs接收的是父组件传递给子组件的没有被props接收的那些属性（数据没有响应式）；

   $listeners接收的是父组件传递的自定义事件(不含 `.native` 修饰器)
   
4. provide & inject 父组件提供的数据，后代组件都可以通过inject注入使用，一般使用在高价组件或者插件中（数据没有响应式）
   

**跨组件传参**   

5. eventBus 创建一个空的Vue实例，通过$on,$emit,$off来实现组件间数据交互

6. vuex 最常用的跨组件传参方式

**为啥没有响应式父组件修改了绑定的值，子组件也会更新？**

因为父组件数据发生修改，会更新页面，子组件的内容也会被更新

#### 父子组件生成及销毁的顺序

生成：

父beforCreate=>父created=>父beforeMount=>子beforeCreate=>子created=>子beforeMount=>子mounted=>父mounted

销毁：

父beforeDestroy=>子beforeDestroy=>子destroyed=>父destroyed



#### Vue性能优化

1. data尽量扁平化处理（Vue）
2. 不需要修改的数据使用Object.freeze冻结处理
3. v-if和v-show区分使用场景（v-if有更大的切换开销，v-show有更大的初始化开销）
4. v-for循环时，注重key的作用
5. 对于没有使用vue语法的模块，用v-pre指令来提升编译效率

