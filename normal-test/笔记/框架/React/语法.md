1. 结构中的变量需要使用 {变量或者表达式}

2. 行内样式style必须写成style={对象}
3. 在react中我们可以使用数组的map方法来展示列表结构
4. dangerouslySetInnerHTML={{__html:html}}

本质上使用的原生的innerHTML，谨慎使用

5. React的htmlFor对应原生的for属性；

   className对应原生的class属性
   
6. React通过state来管理状态。通过props接收传参

7. React.Component默认会执行constructor接收props参数，所以我们可以直接使用this.props

8. 绑定事件方法中this指向处理

   + 箭头函数
   + bind

9. 通过setState修改state中的数据

   + 第一个参数是需要合并到state中的对象
   + 第二个参数是当数据更新后执行的函数
   + setState是一个异步操作

10. 使用useState，可以让函数式组件拥有自己的状态

11. 函数式组件每一次渲染都是一个独立的闭包（异步操作获取的值不是最新的值，只是当前本次函数执行时的值）

    解决：使用useRef获取最新值（只能用current属性）

12. 使用静态属性propTypes（需要引入prop-types）来校验props的类型）

    类组件

    ```js
    import PropTypes from 'prop-types';//按需引入
    //propTypes是用来做类型检测的,用.来设置
    static propTypes = {
    	myname:PropTypes.string
    }
    ```

    函数式组件

    ```js
    //直接给构造函数添加静态属性
    Child.propTypes={
      myname:PropTypes.string
    }
    ```

13. 插槽，直接通过this.props.children获取，放到需要显示的位置即可

    children有四种类型：string（文本）、array（一个以上节点）、object（一个元素节点）、undefined（组件标签没有写内容）

14. 获取ref的方式

    类组件：

    + 字符串ref(通过refs获取)
    + 回调函数ref（第一个参数）
    + createRef（curent属性）

    函数式组件：

    + 回调函数ref（第一个参数）
    + useRef函数创建（curent属性）

15. 使用useRef和createRef来或获取元素或者组件

    + 使用规范：useRef用于函数式组件；createRef用于类组件
    + 创建一个具有单一属性值current的对象
    + 可以使用useRef和createRef可以用来存储任何值，不仅是组件和DOM实例。

16. React Hook

    规则：

    + 只能在**函数最外层**调用 Hook。不要在循环、条件判断或者子函数中调用
    + 只能在 **React 的函数组件**中调用 Hook

    **useState**

    可以让函数式组件拥有自己的状态

    ```jsx
    let [color, setColor] = useState('red');
    ```

    **useEffect**

    + `useEffect(回调函数)`   这个回调函数 会在初次加载完成和 更新完成之后触发(相当于类组件的componenntDidMount和componentDidUpdate)

    + `useEffect(回调函数,[])`  就是相当于 componentDidMount

    + `useEffect(回调函数,[依赖])`  只有依赖发生改变的时候 才会执行回调函数

    + `回调函数`中可以返回一个函数，在组件销毁时执行

      `useEffect(回调函数返回了一个函数)`：组件卸载及每次组件更新之前都会执行返回的函数
      
      `useEffect(回调函数返回了一个函数,[])`：组件卸载会执行返回的函数，相当于class组件的componentWillUnmount
      
      ```js
      //实现class组件的componentWillUnmount
      useEffect(()=>{
        return function(){
    		console.log('相当于componentWillUnmount')
      	}
      },[])
      ```
      

    **useLayoutEffect**

    组件更新渲染执行回调，代码会阻塞页面渲染

    **useEffect**的回调中代码不会阻塞页面渲染

    ```jsx
    useLayoutEffect(() => {
      alert(color)
      // console.log('Layout', color)
    })
    ```

    **useContext**  

    直接获取当前组件的上下文context。

    **useRef**

    获取元素或者组件

    **useReducer** 

    通过 reducer 来管理组件本地的复杂 state

    ```js
    let reducer = (state, action) => {
      // action 就是 dispatch执行的时候传递的哪个对象
      // state就是我们更新之前的老数据
      // 最终结果 是 用这个函数的返回结果 来作为新的state
      switch (action.type) {
        case 'add':
          return {
            ...state,
            count: action.nnn
          }
        case 'minus':
          return {
            ...state,
            count: action.nnn
          }
        default:
          return {
            ...state
          }
      }
    }
    let [state, dispatch] = useReducer(reducer, { count: 100, name: "珠峰" });
    // let [状态，派发函数] = useReducer(reducer函数，初始值（一般都是对象）)
    // dispatch 是用来修改state的； 通过 让 reducer执行的方式来修改state
    // react 会使用 reducer函数的返回结果 来顶替老的state;
    
    ```

    

    **useCallback(需要结合memo函数使用)**

    用来缓存函数的地址，仅当依赖发生改变时，才会返回一个新的函数地址

    **useMemo(需要结合memo函数使用)**

    用来缓存对象，仅当其依赖发生修改时才重新执行返回一个新的对象地址

    **类组件直接使用class extends React.PureComponent去定义组件类即可实现useCallback和useMemo的功能**

    **useImperativeHandle**

    在使用 ref 时自定义暴露给父组件的实例值

    

17. **表单**

    + onInput或者onChange事件监听原生输入框内容修改

18. 受控组件和非受控组件

    + 受控组件（值绑定给state，通过setState设置值）
    + 非受控组件（值未绑定state，直接获取元素取值和赋值）

19. 列表项

    + 列表项需要唯一key值（建议使用id）
    + 删除数据使用数组filter方法

20. 钩子函数（挂载、更新、卸载）

    挂载阶段：

    + 第一个钩子函数constructor  初始化

    + getDerivedStateFromProps 调用render方法之前调用（可以用返回值更新state）

    +  render 组件渲染

    + componentWillMount 挂载完成之前执行

      与getDerivedStateFromProps钩子函数冲突，已废弃并改名为UNSAFE_componentWillMount

    + componentDidMount 组件加载完成之后执行

      ajax请求一般在这里进行

    更新阶段：

    + getDerivedStateFromProps 调用render方法之前调用（可以用返回值更新state）
    + shouldComponentUpdate 组件重新渲染之前执行，返回值决定render是否重新执行
    + render 组件重新渲染
    + getSnapshotBeforeUpdate DOM更新之前调用
    + componentDidUpdate DOM更新后立即调用（不要在这里写触发视图更新的操作

    卸载：

    + componentWillUnmount 当组件从DOM中移除时调用

21. 自定义hook

    自定义 Hook 是一个函数，其名称以 “`use`” 开头，函数内部可以调用其他的 Hook

    为了更好的复用代码

    ```js
    import { useEffect, useReducer } from 'react';
    
    //useLogger是我们自定义的hook
    function useLogger(initState) {
      function reducer(state, action) {
        switch (action.type) {
          case 'ADD':
            return {
              ...state,
              count: state.count + action.num
            }
          case 'MINUS':
            return {
              ...state,
              count: state.count - action.num
            }
    
          default:
            return {
              ...state
            }
        }
      }
      let [state, dispatch] = useReducer(reducer, initState)
    
      let myDispatch = (action) => {
        console.log('老状态：', state);
        dispatch(action)
        // console.log('新状态：', state)
      }
      useEffect(() => {
        console.log('新状态：', state)
      }, [state])
    
      return [state, myDispatch]
    }
    
    //使用useLogger
     let [state, dispatch] = useLogger({ count: 100 })
    ```

22. 上下文（context）

    + context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据
    + 使用 context, 我们可以避免通过中间元素传递 prop
    
    过时的语法：
    
    ```jsx
    //祖宗组件
    static childContextTypes = {
      // 给后代的属性名：属性类型限制
    }
    //或者
    getChildContext(){
      return {
        //给后代的属性名：给后代的属性值
      }
    }
    
//后代组件
    static contextTypes = {
      //要使用的属性名:类型限制
    }
    ```
    
    新语法：
    
    ```jsx
    //context.js
    import React from 'react'
    const MyContext = React.createContext('默认值');// 创造了一个上下文，设置默认值
    export default MyContext
    
    //祖宗组件
    import MyContext from './context.js'
    let obj = {//自定义传给后代的context对象
      theme: 'dark',
      name: "珠峰"
    }
    <MyContext.Provider value={obj}>
      <App />
    </MyContext.Provider>
    
    //后代组件（class组件）
    import MyContext from './context'
    class Child extends React.component{
      static contextType = MyContext 
    	render(){
         console.log(this.context)//使用context
      }
    }
    
    //后代组件（function组件）
    import React, { useContext } from 'react';
    import MyContext from './context.js'
    function Child() {
      const context = useContext(MyContext);
      console.log(context)
    }
    ```
    
23. 高阶组件

    高阶组件是参数为组件，返回值为新组件的函数。

    组件是将 props 转换为 UI，而高阶组件是将组件转换为另一个组件。

    ```jsx
    import React from 'react';
    import ReactDOM from 'react-dom';
    class App extends React.Component {
    
      render() {
        console.log(this.props)//所有合并后的参数
        return <div className=''>
    
        </div>;
      }
    }
    
    function connect(obj = {}) {
      return function (Com) {
        class Temp extends React.Component {
          state = {
            sex: 0
          }
          render() {
            //obj=>函数传递的值
            // this.props=>原组件的props
            //sex=>自定义的值
            return <Com {...obj} {...this.props} sex={this.state.sex} />//渲染原组件，并传递组合后的参数
          }
        }
        return Temp
      }
    }
    
    App = connect({ name: '珠峰', age: 12 })(App)
    ReactDOM.render(<App className='box' />, document.getElementById('root'))
    ```

    可以传递一个函数，让函数内部去决定要传递什么值

    ```jsx
    function connect2(cb) {
      return function (Com) {
        class Temp extends React.Component {
          state = {
            sex: 0,
            age: 666
          }
          render() {
            let obj = cb(this.state);//内部调用回调设置自定义值
            return <Com {...obj} {...this.props} sex={this.state.sex} />
          }
        }
        return Temp
      }
    }
    
    App = connect2((state) => {//设置回调函数和默认返回值
      return {
        name: state.name || "珠峰",
        age: state.age || 12
      }
    })(App)
    ```

    


t    

​    

