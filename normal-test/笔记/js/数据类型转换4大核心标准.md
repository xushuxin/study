# 数据类型转换4大核心标准
```js
一、把其他数据类型转换为 number 类型
1.特定需要转换为 number 的
	Number([val])
	parseInt/parseFloat([val])
2.隐式转换（浏览器内部默认要先转换为 number 再进行计算的）
	isNaN([val])、Math方法
	数学运算(特殊情况：在出现字符串的情况下不是数学运算，是字符串拼接)
	在==比较的时候，有些值需要转换为数字再进行比较

二、把其它数据类型转换为字符串
1.能使用的方法(都是调用其原型的toString)
	toString()
	String()
2.隐式转换（一般都是调用其 toString）
	+ 加号运算时，如果某一边出现字符串，则是字符串拼接
	+ 字符串 == 对象 会把对象转为字符串比较
	+ 把对象转换为数字，需要先 toString()转换为字符串，再去转换为数字
	+ 基于 alert/confirm/prompt/document... 这些方式输出内容，都是把内容先转换为字符串，然后再输出的

三、把其他数据类型转换为布尔类型
1.基于以下方式可以把其他数据类型转换为布尔
	! 转换为布尔值后取反
	!! 转换为布尔类型
	Boolean([val])
2.隐式转换
	在循环或者条件判断中，条件处理的结果就是布尔类型值

规则：只有 0、NaN、空字符串、undefined、null 五个值会变为 false,其余都是 true

四、在==比较的过程中，数据转换的规则
【类型一样的几个特殊点】
	{}=={} : false 对象（引用类型的值）比较的是堆内存的地址
	[]==[] : false
	NaN==NaN : false
【类型不一样的转换规则】
	1.null==undefined : true, null/undefined和其他任何值都不相等
	2.字符串==对象 要把对象转换为字符串
	3.剩下如果==两边数据类型不一致，都是需要转换为数字再进行比较
```

Number转换(隐式转换为数字都是调用Number: isNaN、数学运算、==)
引用类型的值是toString处理后再Number
只用空字符串、空数组、false、null会转为0
```js
	Number('')//0
	Number('0')//0
	Number(null)//0
	Number(false)//0
	Number([])//0 	valueOf() 判断其是否有原始值，没有=>toString()为''=>Number('')=>0
--------------------------------------------
	Number(true)//1
	Number([1])//1 	valueOf() 判断其是否有原始值，没有=>toString()为'1'=>Number('1')
--------------------------------------------
	Number('10')//10
	Number('10px')//NaN
	Number(undefined)//NaN
	Number([1,2])//NaN valueOf() 判断其是否有原始值，没有=>toString()为'1,2'=>Number('1,2')
	Number(function(){})//NaN Number("function(){}")
	Number({})//NaN {}.toSting()=>"[object Object]"
--------------------------------------------
	Number(11111n)//11111 bigint类型会转为 number 类型，并且失去精度
	Number(Symbol('11'))//报错，symbol 类型不可转换为number类型
```

字符串转换：
```js
let result =10 + false +undefined+[]+'Tencent'+null+true+{};
//(10+0+NaN)+''+'Tencent' +'null' +'true' + '[object Object]'
//"NaNTencentnulltrue[object Object]" 
console.log(result)
//＋两边如果出现字符串或者引用类型的值( {}、[]、function(){} ),都会变成字符串拼接(因为原本应该是把引用类型的值转为数字，但是需要先转为字符串，遇到字符串就直接变成字符串拼接了)

//字符串拼接时，基本数据类型转为字符串 String(value)
false=>'false'
null=>'null'
undefined=>'undefined'
11111=>'11111' //整数部分大于等于22位或者小数部分大于等于7位时，会得到科学记数法的字符串
11111n=>'11111'//直接去掉 "n" 获得的数字字符串是准确的
Symbol({})=>"Symbol([object Object])"  //Symbol存储值时，是转为字符串存储的
//对象转为字符串 toString()
{} => "[object Object]"  
function(){}  =>"function(){}"
[] =>""  [1] => "1"  [1,2] =>"1,2"
[undefined]=> ""  [null]=>"" 


//加号出现在字符串或者对象一边不是字符串拼接，如：++i、+i、i++，是数学运算(非数字调用)
var a="10"; ++a//11
var b={}; ++b//NaN
var c=[]; ++c//1  []=>''=>0=>0+1

{}+0;//0 没有变成字符串拼接的原因：把{}当做块处理了，不参与数学运算
({}+0);//"[object Object]0" 用括号运算符包起来就是数学运算了
```


题目
```js
parseInt("")//NaN
Number("")//0
isNaN("")//false 0是有效数字
parseInt(null)//NaN parseInt("null")
Number(null)//0
isNaN("12px")//true Number("12px")=>NaN
parseFloat("1.6px") +parseInt("1.2px") +typeof parseInt(null)
//1.6+1+ typeof NaN
//1.6+1+"number"=>"2.6number"
isNaN(Number(!!Number(parseInt("0.8"))))//false
//parseInt("0.8")=>0
//Number(0)=>0
//!!0=>false
//Number(false)=>0
//isNaN(0)=>false
typeof !parseInt(null) + !isNaN(null)//booleantrue
//!parseInt(null)=>!NaN=>true
//typeof true => "boolean"
//isNaN(null) => false
//!false => true

isNaN 检测数据类型时会把数据转为number 类型再判断
parseInt 会把数据先转为字符串再处理
```

== 比较(不同类型之间)
①undefined==null，undefined/null和其它值都不相等
②字符串和引用类型值比较，引用类型被转为字符串
	对象=>"[object Object]"
	数组=>数组的toString效果相当于调用join方法(undefined和null被当做空字符串处理)
	函数=>函数整体（包括内部代码）转为字符串
③除此之外都会转为数字比较
	  undefined会转为 NaN
	  数组项如果是null或者undefined，转为字符串时，这一项会当做''处理
     false、空字符串、null、[null]、[undefined]会转为 0
     true 会转为 1

```js	
undefined==null//true
undefined == '' //false
undefined == 0//false	
undefined == false //false
undefined == [] //false
undfeind == {}//false

字符串和引用类型值比较(引用类型转为字符串)
'aaa'=={} //false {}.toString()=> '[object Object]'
'0' == [] //false [].toString()=>''
'0' == [0] //true [0].toString()=>'0'
'1,2' == [1,2]//true [1,2].toString=>'1,2'
'function(){}' == function(){}
//true (function(){}).toString()=>'function(){}'

其它的转为数字比较（调用Number）
0 == '' //true  Number('')=>0
0 == false //true Number(false)=>0
0 == {}// false Number({})=>Number("[object Object]")=>NaN
0 == []// true Number([])=>Number('')=>0
0 == [0]// true Number([0])=>Number('0')=>0
0 == [0,1]// false Number([0,1])=>Number('0,1')=>NaN
0 == [false]//false Number([false])=>Number('false')=>NaN
0 == [undefined]//true Number([undefined])=>Number('')=>0
0 == [null]//true Number([null])=>Number('')=>0

总结：==比较时，undefined==null,undefined/null和其它值都不相等
	  false、''、[]、['']、0、[0]、'0'、['0']、[undefined]、[null] 均相等
	  true、1、[1]、1n、[1n]、'1'、['1'] 均相等
数组项如果是null或者undefined，转为字符串时，这一项会当做''处理

```