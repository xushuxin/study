### 跨域（非同源策略请求）

- 同源策略请求 ajax / fetch
- 跨域传输 

#### 最早的跨域处理

部署到web服务器上：同源策略

测试环境 

- xampp启动服务 修改本地的host文件

```
127.0.0.2:1234 http://api.qq.com/
```

本地服务：http://127.0.0.2:1234/index.html

服务器端接口：http://api.qq.com/getData



#### 产生跨域的原因

##### 服务器拆分导致跨域

web服务器：静态资源 kbs.sports.qq.com

data服务器：业务逻辑和数据分析 api.sports.qq.com

图片服务器

##### 第三方开源的数据接口也会导致跨域



#### 判断是否跨域

三者都一样就是同源，只要有一个不同就是跨域

- 协议
- 域名
- 端口号

web服务器地址；http://127.0.0.1:3000/index.html

数据接口地址：http://127.0.0.1:4000/list



#### 跨域处理方案

##### 1. JSONP

script、img、link、iframe 不存在跨域请求的限制

jsonp是利用script标签不存在跨域请求的限制。

+ 客户端通过script向服务器发送请求，同时会把本地的一个函数名传递给服务器
+ 服务器接收到请求后准备数据，给客户端返回一个字符串，字符串的的内容是函数执行并传递JSON格式的数据
+ 浏览器接收到返回数据后会执行函数

注意点：

1. 必须是script这种没有跨域请求限制的方式
2. 函数必须是全局的
3. JSONP需要服务器端支持

**jsonp的实现**

新建1.jsonp.js

```js
//jquery发送jsonp请求
$.ajax({
  url:'http://127.0.0.1:8001/list',
  method:'get',
  dataType:'jsonp',//执行的是JSONP的请求
  success:res=>{
    console.log(res);
  }
})
```

需要服务器端支持

新建serverJsonp.js（借助express搭建服务）

```js
let express = require('express'),
		app =express();
app.listen(8001,()=>{
	console.log('ok！')
});
app.get('list',(req,res)=>{
  let {
    callback = Function.prototype
  } = req.query;
  let data ={
    code:0,
    message:'珠峰培训'
  };
  res.send(`${callback}(JSON.stringify(data))`)
})
```

node jsonpServer启动服务

前端http-server启动静态服务

index.html查看效果

**React的字符组件方法传递，以及IOS混合app中的伪URL传参，都是和JSONP的原理一样**

问题：

1. JSONP只能处理GET请求
2. 安全性不是很好，请求容易被拦截

#### 2. CORS跨域资源共享

- 客户端发送ajax/fetch请求

  Axios的常用基础配置

  ```js
  axios.defaults.baseURL = 'http://127.0.0.1:8888';//设置请求地址的公共部分
  axios.defaults.withCredentials = true;//发送跨域请求时携带资源凭证（cookie）
  axios.defaults.headers['Content-Type'] = 'application/x-www-form-urlencoded';//告诉服务器客户端发送的数据的类型
  
  //转换请求的数据的对象格式为url参数的格式
  axios.defaults.transformRequest = function(data){
    if(!data) return data;
    let result ='';
    for (let attr in data){
      if(!data.hasOwnProperty(attr)) break;
      result+ =`&${$attr}=${data[attr]}`;
    }
    return result.substring(1)
  }
  
  //拦截请求，处理返回的数据
  axios.interceptors.response.use(function onFulfiiled(response){
    return response.data;
  },function onRejected(reason){
    return Promise.reject(reason);
  })
  
  //指定2或者3开头的状态码为成功
  axios.defaults.validateStatus = function(status){
    return /^(2|3)\d{2}$/.test(status);
  }
  ```

  application/x-www-form-urlencoded：表单的默认编码格式，会把请求数据转为url参数格式，问号拼接到请求的url地址后面进行传参

- 服务器端设置相关的响应头信息（需要处理options试探性请求）

  ```js
  app.use((req,res,next)=>{
    res.header("Access-Control-Allow-Origin","允许跨域请求的源");
    res.header("Access-Control-Allow-Credentials",true);//允许携带跨域资源凭证（cookie）
    res.header("Access-Control-Allow-Headers","Content-Type,Content-Length,Authorization,Accept,X-Requested-With");//允许客户端上送的请求头
    res.header("Access-Control-Allow-Methods",'PUT,POST,GET,DELETE，HEAD,OPTIONS');//允许发送的请求类型
    //处理OPTIONS请求
    if(req.method === 'OPTIONS'){
      res.send('OK!');
      return;
    }
    next();
  })
  ```

  局限性：

  设置了Access-Control-Allow-origin为*支持多源请求（不安全）后就不允许再携带cookie了

#### 3. http proxy

webpack-dev-server配置代理devServer.proxy

```js
devServer:{
  proxy:{
    '/'{
      target:'http://127.0.0.1:3001',
      changeOrigin:true//设为true时devServer会帮我们起一个服务来做中层的代理
    }
  }
}
```

#### 4. nginx反向代理

www.zhufeng1peixun.cn  代理到=>  www.zhufengpeixun.com

proxy服务器

```js
server {
  listen 80;
  server_name www.zhufengpeixun.com
  location / {
    proxy_pass www.zhufengpeixun.cn;#反向代理
    proxy_cookie_demo www.zhufengpeixun.cn www.zhufengpeixun.com;#处理cookie
    add_header Access-Control-Allow-Origin www.zhufengpeixun.cn;
    add_header Access-Control-Allow-Credentials true;
  }
}
```

不需要前端做啥

----------------------------------------------------------------------------------------------

以下为不常用方案：

#### 5. postMessage

+ 新建一个文件夹MESSAGE，包含页面A.html和B.html

  MESSAGE/A.html

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Page A</title>
  </head>
  <body>
    <div>Page A</div>
    <iframe id="iframe" src="http://127.0.0.1:1002/MESSAGE/B.html" frameborder="0"></iframe>
    <script>
      // ifrme加载后页面后再向B页面发送请求
      iframe.onload=function(){
        // 使用postMessage将数据发送到其他窗口时，始终指定精确的目标origin，而不是*。 恶意网站可以在您不知情的情况下更改窗口的位置，因此它可以拦截使用postMessage发送的数据。
        iframe.contentWindow.postMessage('珠峰珠峰','http://127.0.0.1:1002')
      }
      //监听B页面的信息，获取返回信息
      window.onmessage = function(ev){
        if(ev.origin!=='http://127.0.0.1:1002') return;
        if(typeof ev.data !=='string') return;
        console.log(ev.data);
      }
    </script>
  </body>
  </html>
  ```

  MESSAGE/B.html

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Page B</title>
  </head>
  <body>
    <script>
      //监听A页面的信息，注意应该判断origin是否与预期一致
      //并且验证origin后，应该始终验证接收到的消息的语法，否则受信任的网站中的安全漏洞可能会在您的网站中打开跨网站脚本漏洞
      window.onmessage=function(ev){
        console.log(ev.origin);
        console.log(ev.data)
        if(ev.origin!=='http://127.0.0.1:1001') return;
        //还需要进行参数信息校验
        if(typeof ev.data !== 'string') return;
        // ev.source => A页面
        //返回数据给A页面
        ev.source.postMessage(ev.data+'@@@',ev.origin)
      }
    </script>
  </body>
  </html>
  ```

  

+ 而是用express搭建两个不同端口的服务,并设置静态资源地址,这样我们可以通过1001端口访问A页面，通过1002端口访问B页面，模拟出不同源的两个页面

  service1.js

  ```js
  const express =require('express'),
        app = express();
  app.listen(1001,_=>{
    console.log('listen 1001')
  })
  app.use(express.static('./'));
  ```

  service2.js

  ```js
  const express =require('express'),
        app = express();
  app.listen(1002,_=>{
    console.log('listen 1002')
  })
  app.use(express.static('./'));
  ```

+ 启动两个服务,通过http://127.0.0.1/MESSAGE/A.html打开A页面，查看响应结果

#### 6. socket.io （基于Websocket协议跨域）

前端处理

需要下载[socket.io](https://socket.io/get-started/chat/)

```
npm install socket.io
```

```html
<script src="/socket.io/socket.io.js"> </script>
<script>
	let socket = io('http://127.0.0.1:3001');
  //连接成功处理
  socket.on('connect',function(msg){
    //监听服务端消息
    socket.on('message',function(msg){
      console.log('data from server:'+ msg);
    })
    //监听服务端关闭
    socket.on('disconnect',function(){
      console.log('server socket has closed!');
    })
  });
  //发送请求给服务器端
  socket.send("zhufengpeixun");
</script>
```

服务器端处理

node+express并安装socket模块

```js
npm install express socket.io -S
```

```js
//监听socket连接：server是服务器创建的服务
socket.listen(server).on('connection',function(client){
  //接收信息
	client.on('message',function(msg){
    //msg => 客户端传递的信息
    //do Some thing
    client.send(msg+'@@');//响应信息
  })
  
  //断开处理
  client.on('disconnect',function(){
    console.log('client socket has closed!');
  })
})
```

#### 7. document.domain + iframe

只能实现：同一个主域，不同子域之间的操作

如：v.qq.com和sports.qq.com属于同一个主域

父页面A http://www/zhufengpeixun.cn/A.html

```html
<iframe src="http://www.zhufengpeixun.cn/B.html"></iframe>	
<script>
	document.domain = 'zhufengpeixun.cn';//设置主域名
  var user = 'admin';
</script>
```

子页面B http://www.zhufengpeixun.cn/B.html

```html
<script>
	document.domain = 'zhufengpeixun.cn';//设置主域名
  alert(window.parent.user);//获取父页面数据
</script>
```

#### 8. window.name + iframe

新建3个页面A.html、B.html、proxy.html

A和proxy同源，A和B非同源

NAME/A.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <iframe style="display: none;" id ="iframe" src="http://127.0.0.1:1002/NAME/B.html" frameborder="0"></iframe>
  <script>
    //onload会触发两次
    let count = 0;
    iframe.onload =function(){
      if(count===0){
        //需要我们先把src指向同源地址才可以获取页面的name（修改src不会改变window.name）
        iframe.src="http://127.0.0.1:1001/NAME/proxy.html";
        count++;
        return;
      }
      //第二次才获取name的值（也就是B页面的传值）
      console.log(iframe.contentWindow.name)
    }
  </script>
</body>
</html>
```

NAME/B.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Page B</title>
</head>
<body>
  <script>
    //服务器端要返回给A的信息都在window.name中存储
    window.name = '珠峰培训';
  </script>
</body>
</html>
```

NAME/proxy.html 是空页面

启动service1 和 service2

通过http://127.0.0.1:1001/NAME/A.html查看控制台打印结果 