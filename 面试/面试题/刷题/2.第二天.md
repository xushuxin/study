题目一：
Promise.allSettled了解吗？动手实现一下Promise.allSettled?
```js
Promise.allSettled = function(promises){
    let len = promises.length;
    let data = [],n = 0;
    return new Promise((resolve,reject) => {
        for(let i = 0; i < len;i++){
            let promise = promises[i];
            promise.then(value=>{
                data[i] = {status: "fulfilled", value};
                n ++;
                if(n === len) resolve(data);
            },reason=>{
                data[i] = {status: "rejected",reason};
                n++
                if(n === len) resolve(data);
            })
        } 
    })
}

var p1 = new Promise((resolve,reject) => {
    setTimeout(()=>{
        resolve('666')
    })
})
var p2 = new Promise((resolve,reject) => {
    reject('hehehe')
})
var p3 = new Promise((resolve,reject) => {
    resolve('hehehe')
})

Promise.allSettled([p1,p2,p3]).then(data=>{
    console.log(data)
})
```

题目二：
什么是同步？什么是异步？

同步和异步是一种消息通知机制

-  同步阻塞: A调用B，B处理获得结果，才返回给A。A在这个过程中，一直等待B的处理结果，没有拿到结果之前，需要A（调用者）一直等待和确认调用结果是否返回，拿到结果,然后继续往下执行。

    做一件事，没有拿到结果之前，就一直在这等着，一直等到有结果了,再去做下边的事

- 异步非阻塞: A调用B，无需等待B的结果，B获取到结果后通知A来处理。

    做一件事，不用等待事情的结果，然后就去忙别的了，有了结果，再通过状态来告诉我，或者通过回调函数来处理。

题目三：
什么是宏任务？什么是微任务？

我的回答：

+ 微任务：js引擎发起的异步任务，执行时机在同步代码执行完成之后，宏任务结束之前。

+ 宏任务：宏任务包括了同步代码执行以及检查并执行微任务的过程

  在事件循环中，会先执行同步代码，执行完同步代码后，(会更新一次DOM)，然后执行所有微任务，（这时可能存在页面重新渲染），最后执行下一个宏任务，开启下一次事件循环。

老师的答案：

+ 微任务：一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。

+ 宏任务：宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合。

```markdown
常见微任务：

1. Promise.then

2. MutaionObserver

3. Object.observe（已废弃；Proxy 对象替代）

4. process.nextTick（Node.js）

 常见宏任务 ：

 1. script (可以理解为外层同步代码)

 2. setTimeout/setInterval

 3. UI rendering/UI事件

 4. postMessage，MessageChannel

 5. setImmediate，I/O（Node.js）
```

