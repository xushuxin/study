##### 🎈题目一：

编写一个方法，该方法接收两个参数，分别为 k 和 一个无序的纯数字数组。该方法在执行后，会返回数组中第 k 大的数字。特别注意，如果数组中，有两位数值一样的数字，同数值数字排名并列。如 [3,1,3,2,5,4,5] 中，第 1 大的数字为 5，第2大的数字为 4，第5大的数字为 1

```js
class MinHeap{
    constructor(k){
        this.data = [];
        this.k = k;
    }
    push(val){
        if(this.size < this.k){
            this.data.push(val);
            this.shift_up(this.size-1);
        }else if(val > this.top){
            this.data[0] = val;
            this.shift_down(0);
        }
    }
    pop(){
        if(this.size === 0) return;
        if(this.size === 1) return this.data.pop();
        let item = this.data[0];
        this.data[0] = this.data.pop();
        this.shift_down(0);
        return item;
    }
    swap(i,j){
        let temp = this.data[i];
        this.data[i] = this.data[j];
        this.data[j] = temp;
    }
    shift_up(i){
        while(i > 0 &&  this.data[i] < this.data[i - 1 >> 1]){
            this.swap(i, i - 1>>1);    
            i = i - 1 >> 1;
        }
    }

    shift_down(i){
        while( i * 2 + 1 < this.size){
            let temp = i;
            if(this.data[i] > this.data[i * 2 + 1]){
                temp = i * 2 + 1;
            }
            if(i * 2 + 2 < this.size && this.data[temp] > this.data[i * 2  + 2]){
                temp = i * 2 + 2; 
            }
            if(temp === i) break;
            this.swap(i,temp);
            i = temp;
        }
    }
    get top(){
        return this.data[0];
    }
    get size(){
        return this.data.length;
    }
}

function getKLargeNum(k, arr){
    arr = [...new Set(arr)];
    console.log(arr);
    let minHeap = new MinHeap(k);
    for(let i = 0;i<arr.length;i++){
        minHeap.push(arr[i]);
    }
    console.log(minHeap)
    return minHeap.top;
}
console.log(getKLargeNum(5,[3,1,3,2,5,4,5]))
```

也可以先去重，后排序，排序可以使用快排等排序算法

##### 🎈题目二：

\_\_proto\_\_ 和 prototype 之前有什么关系？

答：\_\_proto\_\_是实例对象的一个属性，指向其构造函数的原型对象；

prototype是构造函数的一个属性，指向构造函数的原型对象；

它们是从不同角度，对原型对象的标识。

##### 🎈题目三：

call(), .apply() .bind() 的区别和作用？bind 方法如何来实现？

call：调用函数，将函数执行上下文中的this指定为第一个参数，并将剩余参数传递给函数

apply：作用和call基本一样，只是传参是通过一个数组的方式传递

bind：返回一个新的函数，返回的函数调用时，内部会调用原函数并将this指向第一个参数，并将剩余参数与原函数的参数合并，传递给原函数

bind实现

```js
Function.prototype.bind = function(){
  let fn = this;
	let thisArg = arguments[0];
  let args = [].slice.call(arguments,1)
  return function Fn(...innerArgs){
		console.log('this:',this)
    if(this instanceof Fn) { thisArg = this; }
    fn.apply(thisArg,[...args,...innerArgs])
  }
}
```

