****

##### 第一题 Vue3 中 Teleport 的作用是什么？

Teleport 的作用就是将一个嵌套在组件内部的某些内容可以渲染到当前组件外部

假设我们有一个modal组件，该组件分为触发modal打开的button以及模态框本体

![image-20210518083906314](/Users/xushuxin/Library/Application Support/typora-user-images/image-20210518083906314.png)

但我们需要给模态框position: absolute时，其会以其定位父级也就是含有相对定位的div进行偏移，同时将会受到其父级样式影响

此时我们就只能将组件拆分为两个组件或者用一个其他的全局状态进行控制

如果使用teleport就可以将modal渲染到body标签内，避免上面的问题

![image-20210518084016647](/Users/xushuxin/Library/Application Support/typora-user-images/image-20210518084016647.png)

在上面的代码中 可以看到modal外面包了一层teleport ，然后可以可以通过 to 来指定将telepot的内容插入到body标签

##### 第二题 说一下vue3的composition api?

composition api意为组合式api，主要是代码组织结构上的变动

在去说composition api的是时候，更多的还是结合vue2的options api来说

用过vue的或者稍微了解过vue2的人 应该对options API都还是比较熟系的

比如：

从父组件直接传入的数据存放于props，方法存放于methods等等。

但是问题点就是，如果组件稍微复杂一些，就会出现反复横跳的情况

一会扒拉到最上面找数据，一会扒拉到下面找方法

那composition api就是来解决这个问题的

vue3当中新增加了一个生命周期函数setup，setup将在创建组件之前被执行，一旦props被解析时，setup将服务于composition api充当入口点

**那我们再继续说一下composition api 与 options api的不同**

1. 响应式数据声明上

+ vue3通过ref/reactive两个方法都可以声明响应式数据

+ ref所声明的响应式变量将会返回一个包含有value属性的对象，value的值就是该响应式变量所对应的值，所以在不论在获取还是改变ref声明的响应式变量时都需要通过.value进行操作

+ reactive返回的则是通过Proxy处理后的对象

![image-20210518084552337](/Users/xushuxin/Library/Application Support/typora-user-images/image-20210518084552337.png)

2. 生命周期函数使用方式上

+ 使用生命周期函数时，需要从vue中引入对应生命周期函数例如onMounted
+ 生命周期函数接受一个函数作为参数，该函数将会在对应生命周期阶段被执行

![image-20210518084710099](/Users/xushuxin/Library/Application Support/typora-user-images/image-20210518084710099.png)

3. watch使用方式

+ watch作为函数接受至少两个参数，第一个参数为被watch的响应式数据，第二个参数为回调函数

+ 然后当watch接受的响应式数据不同会有不同的使用方式
  - 当watch的数据为通过ref声明的响应式变量时：watch直接接受ref响应式变量如watch(refValue)
  - 当watch数据为通过reactive声明时：需要传入一个函数，该函数返回reactive变量如
    watch(() => reactiveValue.value)
  - 同时新增watchEffect，他会收集内部依赖，当内部依赖发生改变时就会被执行

![image-20210518084932199](/Users/xushuxin/Library/Application Support/typora-user-images/image-20210518084932199.png)

4. props的接收

   props现在作为setup的第一个参数进行接收，使用props时可以通过vue暴露的toRefs方法将props上的属性转为独立的ref响应式变量来使用

   ![image-20210518085018825](/Users/xushuxin/Library/Application Support/typora-user-images/image-20210518085018825.png)

5. 在setup当中代码将可以根据功能进行组织并提取

   这极大程度的解决了以往代码可读性较低以及逻辑服用难的缺点

6. 扩展内容：

   + 在vue3中虽然是使用的composition api，但是目前来说也是可以使用options api的方式进行的 ，也就是说在vue3里面是可以写vue2的语法的

   + 另外一个注意事项是在setup中是没有this的，因为setup执行是在组件创建之前，这时还并没有组件实例，所以在setup中并没有this

     那如果需要使用到一些实例上的方法，可以通过getCurrentInstance方法先获取实例在进行操作

##### 第三题 vue3中v-model的变化

1. vue3取消了.sync修饰符的使用，直接使用v-model进行替换就行

![image-20210518085247481](/Users/xushuxin/Library/Application Support/typora-user-images/image-20210518085247481.png)

2. 对于自定义组件使用v-model的时候，prop与事件的默认名称变更，从vue2版本的value/@input变更为modelValue/@update:modelValue

3. 修改model的名称从原来的model选项进行修改，变更为传递参数给model，写法为v-model:argument
4. 使用v-model:argument后会改变prop和事件名为argument/@update:argument

![image-20210518085435816](/Users/xushuxin/Library/Application Support/typora-user-images/image-20210518085435816.png)

5. 现在一个组件可以同时使用多个v-model进行绑定（vue2.只允许在组件上使用一个 model）

6. 在vue3中v-model支持自定义修饰符，他将会通过props中的modelModifiers属性接收

   ![image-20210518085535537](/Users/xushuxin/Library/Application Support/typora-user-images/image-20210518085535537.png)

什么场景会用到多个v-model？

比如：弹窗

```vue
<modal v-model:visible="isVisible" v-model:content="content"></modal>
```

